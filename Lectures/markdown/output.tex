\section{Lecture 11: Complete Single-Cycle MIPS Processor and
Performance
Analysis}\label{lecture-11-complete-single-cycle-mips-processor-and-performance-analysis}

\emph{By Dr.~Isuru Nawinne}

\subsection{11.1 Introduction}\label{introduction}

This lecture completes the single-cycle MIPS processor design by
providing comprehensive analysis of control signals for all instruction
types (R-type, Branch, Load, Store, Jump), introducing detailed timing
analysis with concrete delay values, and demonstrating the fundamental
performance limitations that motivate the evolution toward multi-cycle
and pipelined implementations. We build upon previous datapath and
control unit knowledge to create a functioning processor while
understanding why single-cycle design, though conceptually simple,
proves inefficient in practice.

\subsection{11.2 Lecture Overview and
Context}\label{lecture-overview-and-context}

\subsubsection{11.2.1 Recap from Previous
Lectures}\label{recap-from-previous-lectures}

The foundational work completed in previous lectures includes:

\textbf{Completed Topics:}

\begin{itemize}
\tightlist
\item
  Datapath components: Register file, ALU, memories, adders,
  multiplexers
\item
  Sign extension and shifting for immediate operands
\item
  Control unit concept and ALU control generation
\item
  Control signal purposes and functions
\end{itemize}

\textbf{Current Focus:}

\begin{itemize}
\tightlist
\item
  Complete control signal analysis for all instructions
\item
  Detailed walkthrough of instruction execution
\item
  Jump instruction integration
\item
  Timing analysis with concrete delay values
\item
  Performance limitations of single-cycle design
\end{itemize}

\subsubsection{11.2.2 Instruction Subset
Review}\label{instruction-subset-review}

\textbf{Selected Instructions for Study:}

\begin{itemize}
\tightlist
\item
  \textbf{R-type}: ADD, SUB, AND, OR (arithmetic/logic operations)
\item
  \textbf{Load Word (LW)}: Memory read
\item
  \textbf{Store Word (SW)}: Memory write
\item
  \textbf{Branch if Equal (BEQ)}: Conditional branch
\item
  \textbf{Jump (J)}: Unconditional jump
\end{itemize}

\textbf{Coverage:}

\begin{itemize}
\tightlist
\item
  Represents 95\% of MIPS microarchitecture hardware
\item
  Comprehensive enough for understanding design principles
\item
  Omits some I-type arithmetic (covered conceptually)
\item
  Foundation for complete processor understanding
\end{itemize}

\subsection{11.3 Control Unit Inputs and
Outputs}\label{control-unit-inputs-and-outputs}

\subsubsection{11.3.1 Control Unit Inputs}\label{control-unit-inputs}

\textbf{Total Input Bits:} 12 bits

\paragraph{Primary Input - Opcode (6
bits):}\label{primary-input---opcode-6-bits}

\begin{itemize}
\tightlist
\item
  Bits 26-31 of instruction
\item
  Identifies instruction type
\item
  Used for almost all control signal generation
\item
  Most significant determinant of control behavior
\end{itemize}

\paragraph{Secondary Input - Funct Field (6
bits):}\label{secondary-input---funct-field-6-bits}

\begin{itemize}
\tightlist
\item
  Bits 0-5 of instruction
\item
  Only relevant for R-type instructions (opcode = 000000)
\item
  Specifies ALU operation for R-type
\item
  Ignored for I-type and J-type instructions
\end{itemize}

\textbf{Usage Pattern:}

\begin{itemize}
\tightlist
\item
  Opcode always examined
\item
  Funct field examined only when opcode = 0 (R-type)
\item
  Combined with ALUOp for final ALU control signal
\end{itemize}

\subsubsection{11.3.2 Control Unit Outputs}\label{control-unit-outputs}

\textbf{Total Output Bits:} 9 bits (8 signals, one is 2-bit)

\textbf{Control Signals Generated:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{RegDst} (1 bit): Select register write address
\item
  \textbf{Branch} (1 bit): Instruction is branch type
\item
  \textbf{MemRead} (1 bit): Enable memory read
\item
  \textbf{MemtoReg} (1 bit): Select register write data source
\item
  \textbf{MemWrite} (1 bit): Enable memory write
\item
  \textbf{ALUSrc} (1 bit): Select ALU second operand source
\item
  \textbf{RegWrite} (1 bit): Enable register file write
\item
  \textbf{ALUOp} (2 bits): ALU operation category
\end{enumerate}

\textbf{Additional Signal for Jump:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{8}
\tightlist
\item
  \textbf{Jump} (1 bit): Select jump target for PC
\end{enumerate}

\textbf{Implementation:}

\begin{itemize}
\tightlist
\item
  Combinational logic circuit
\item
  Inputs: Opcode and Funct field
\item
  Outputs: Control signals
\item
  Design method: Truth tables, Karnaugh maps, Boolean minimization
\item
  To be implemented in Lab 5
\end{itemize}

\subsection{11.4 R-Type Instruction Detailed
Analysis}\label{r-type-instruction-detailed-analysis}

\subsubsection{11.4.1 Instruction Format}\label{instruction-format}

\textbf{Encoding Structure (32 bits):}

\begin{itemize}
\tightlist
\item
  \textbf{Bits 26-31}: Opcode = 000000 (0) - ALL R-type instructions
\item
  \textbf{Bits 21-25}: RS (5 bits) - First source register
\item
  \textbf{Bits 16-20}: RT (5 bits) - Second source register
\item
  \textbf{Bits 11-15}: RD (5 bits) - Destination register
\item
  \textbf{Bits 6-10}: SHAMT (5 bits) - Shift amount
\item
  \textbf{Bits 0-5}: Funct (6 bits) - Function code (specifies
  operation)
\end{itemize}

\textbf{Example: ADD \$1, \$2, \$3}

Encoding: 000000 00010 00011 00001 00000 100000
\textbar Opcode\textbar{} RS \textbar{} RT \textbar{} RD
\textbar SHAMT\textbar{} Funct \textbar{} \textbar{} 0 \textbar{} 2
\textbar{} 3 \textbar{} 1 \textbar{} 0 \textbar{} 32 \textbar{}

\textbf{Operation:} \texttt{\$1\ =\ \$2\ +\ \$3}

\subsubsection{11.4.2 Datapath Elements
Used}\label{datapath-elements-used}

Figure 1: R-Type Instruction Datapath

\textbf{Active Elements (shown in black):}

\begin{itemize}
\tightlist
\item
  Instruction Memory: Fetch instruction
\item
  Program Counter: Current instruction address
\item
  PC + 4 Adder: Calculate next sequential address
\item
  Register File: Read RS, RT; Write RD
\item
  Multiplexer (RegDst): Select RD as write address
\item
  Multiplexer (ALUSrc): Select RT value (not immediate)
\item
  ALU: Perform operation specified by funct
\item
  Multiplexer (MemtoReg): Select ALU result (not memory)
\item
  Multiplexer (PC source): Select PC+4 (not branch)
\end{itemize}

\textbf{Inactive Elements (grayed out):}

\begin{itemize}
\tightlist
\item
  Data Memory: Not accessed
\item
  Sign Extender: Not used (no immediate value)
\item
  Branch Target Adder: Calculated but not used
\item
  Shift Left 2: Not used
\end{itemize}

\subsubsection{11.4.3 Control Signal Values for
R-Type}\label{control-signal-values-for-r-type}

\textbf{Exercise Example: ADD \$1, \$2, \$3}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Signal & Value & Reason \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
RegDst & 1 & Write to RD (bits 11-15), not RT \\
Branch & 0 & Not a branch instruction \\
MemRead & 0 & Not reading from memory \\
MemtoReg & 0 & Write ALU result (not memory data) \\
ALUOp & 10 & R-type: Consult funct field \\
MemWrite & 0 & Not writing to memory \\
ALUSrc & 0 & Second operand from register RT (not immediate) \\
RegWrite & 1 & Write result to destination register \\
\end{longtable}
}

\textbf{Detailed Explanations:}

\textbf{RegDst = 1:}

\begin{itemize}
\tightlist
\item
  Multiplexer selects input 1
\item
  Input 1: Bits 11-15 (RD field)
\item
  Input 0: Bits 16-20 (RT field)
\item
  R-type destination always in RD
\end{itemize}

\textbf{Branch = 0:}

\begin{itemize}
\tightlist
\item
  Not a branch instruction
\item
  Branch control AND Zero → 0 AND X = 0
\item
  PC source multiplexer selects PC+4
\end{itemize}

\textbf{MemRead = 0, MemWrite = 0:}

\begin{itemize}
\tightlist
\item
  R-type doesn't access data memory
\item
  Memory control signals disabled
\item
  Data memory outputs ignored (don't care)
\end{itemize}

\textbf{MemtoReg = 0:}

\begin{itemize}
\tightlist
\item
  Multiplexer selects ALU result
\item
  Not memory data (memory not accessed)
\item
  ALU result goes to register write data
\end{itemize}

\textbf{ALUOp = 10 (binary):}

\begin{itemize}
\tightlist
\item
  Indicates R-type instruction
\item
  ALU Control Unit examines funct field
\item
  For ADD: funct = 100000 → ALU Control = 0010 (ADD)
\end{itemize}

\textbf{ALUSrc = 0:}

\begin{itemize}
\tightlist
\item
  Multiplexer selects register value
\item
  Register file Read Data 2 (RT value)
\item
  Not sign-extended immediate
\end{itemize}

\textbf{RegWrite = 1:}

\begin{itemize}
\tightlist
\item
  Enable register file write
\item
  Result written to RD at clock edge
\item
  Essential for saving computation result
\end{itemize}

\subsubsection{11.4.4 Execution Steps for
R-Type}\label{execution-steps-for-r-type}

\textbf{Step 1: Instruction Fetch}

\begin{itemize}
\tightlist
\item
  PC value → Instruction Memory address
\item
  Instruction word retrieved
\item
  Opcode (000000) sent to Control Unit
\end{itemize}

\textbf{Step 2: Control Signal Generation}

\begin{itemize}
\tightlist
\item
  Control Unit decodes opcode = 0
\item
  Identifies R-type instruction
\item
  Generates all control signals
\item
  Sends funct field to ALU Control
\end{itemize}

\textbf{Step 3: Register Read}

\begin{itemize}
\tightlist
\item
  RS field (00010 = 2) → Read Address 1
\item
  RT field (00011 = 3) → Read Address 2
\item
  Read Data 1 = \$2 value
\item
  Read Data 2 = \$3 value
\end{itemize}

\textbf{Step 4: ALU Operation}

\begin{itemize}
\tightlist
\item
  ALUSrc = 0: Select RT value for Input B
\item
  Input A = \$2 value, Input B = \$3 value
\item
  ALU Control = 0010 (ADD operation)
\item
  ALU Result = \$2 + \$3
\end{itemize}

\textbf{Step 5: Register Write Preparation}

\begin{itemize}
\tightlist
\item
  MemtoReg = 0: Select ALU result
\item
  RegDst = 1: Select RD (00001 = 1)
\item
  Write Data = ALU result
\item
  Write Address = \$1
\end{itemize}

\textbf{Step 6: Clock Edge Actions}

\begin{itemize}
\tightlist
\item
  RegWrite = 1 enabled
\item
  ALU result written to \$1
\item
  PC updated to PC + 4
\item
  Next instruction fetch begins
\end{itemize}

\subsection{11.5 Branch If Equal Instruction Detailed
Analysis}\label{branch-if-equal-instruction-detailed-analysis}

\subsubsection{11.5.1 Instruction Format}\label{instruction-format-1}

\textbf{Encoding Structure (32 bits):}

\begin{itemize}
\tightlist
\item
  \textbf{Bits 26-31}: Opcode = 000100 (4) - BEQ
\item
  \textbf{Bits 21-25}: RS (5 bits) - First comparison register
\item
  \textbf{Bits 16-20}: RT (5 bits) - Second comparison register
\item
  \textbf{Bits 0-15}: Immediate (16 bits) - Branch offset (in
  instructions)
\end{itemize}

\textbf{Example: BEQ \$1, \$2, 100}

Encoding: 000100 00001 00010 0000000001100100 \textbar Opcode\textbar{}
RS \textbar{} RT \textbar{} Immediate \textbar{} \textbar{} 4 \textbar{}
1 \textbar{} 2 \textbar{} 100 \textbar{}

\textbf{Operation:}
\texttt{If\ (\$1\ ==\ \$2)\ then\ PC\ =\ PC\ +\ 4\ +\ (100\ ×\ 4)}

\subsubsection{11.5.2 Datapath Elements
Used}\label{datapath-elements-used-1}

Figure 2: Branch If Equal Instruction Datapath

\textbf{Active Elements:}

\begin{itemize}
\tightlist
\item
  Instruction Memory: Fetch instruction
\item
  Program Counter \& PC+4 Adder
\item
  Register File: Read RS, RT (no write)
\item
  ALU: Subtract RT from RS
\item
  Zero Flag: Compare result to zero
\item
  Sign Extender: Extend 16-bit offset to 32-bit
\item
  Shift Left 2: Convert word offset to byte offset
\item
  Branch Target Adder: Calculate PC + 4 + (offset × 4)
\item
  AND Gate: Combine Branch signal and Zero flag
\item
  PC Source Multiplexer: Select next PC value
\end{itemize}

\textbf{Inactive Elements:}

\begin{itemize}
\tightlist
\item
  Data Memory: Not accessed
\item
  Register Write: Not writing to registers
\item
  ALU Result (except Zero flag): Not used
\end{itemize}

\subsubsection{11.5.3 Control Signal Values for
BEQ}\label{control-signal-values-for-beq}

\textbf{Exercise Example: BEQ \$1, \$2, 100}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Signal & Value & Reason \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
RegDst & X & Don't care (not writing to register) \\
Branch & 1 & This IS a branch instruction \\
MemRead & 0 & Not reading from memory \\
MemtoReg & X & Don't care (not writing to register) \\
ALUOp & 01 & Perform SUBTRACT for comparison \\
MemWrite & 0 & Not writing to memory \\
ALUSrc & 0 & Compare two register values (not immediate) \\
RegWrite & 0 & Not writing to register file \\
\end{longtable}
}

\textbf{Detailed Explanations:}

\textbf{RegDst = X (Don't Care):}

\begin{itemize}
\tightlist
\item
  RegWrite = 0, so write address irrelevant
\item
  No register write operation
\item
  Multiplexer output ignored
\item
  Using X simplifies Boolean logic
\end{itemize}

\textbf{Branch = 1:}

\begin{itemize}
\tightlist
\item
  Identifies instruction as branch type
\item
  Feeds into AND gate with Zero flag
\item
  PCSrc = Branch AND Zero
\item
  If Zero = 1 (values equal): Take branch
\item
  If Zero = 0 (values differ): Don't take branch
\end{itemize}

\textbf{MemRead = 0, MemWrite = 0:}

\begin{itemize}
\tightlist
\item
  Branch doesn't access memory
\item
  Memory control signals disabled
\end{itemize}

\textbf{MemtoReg = X (Don't Care):}

\begin{itemize}
\tightlist
\item
  RegWrite = 0, so write data source irrelevant
\item
  Multiplexer output ignored
\end{itemize}

\textbf{ALUOp = 01:}

\begin{itemize}
\tightlist
\item
  Specifies SUBTRACT operation
\item
  ALU Control receives 01
\item
  Generates ALU Control = 0110 (SUB)
\item
  Independent of funct field
\end{itemize}

\textbf{ALUSrc = 0:}

\begin{itemize}
\tightlist
\item
  Need RT value from register (not immediate)
\item
  Immediate used for branch target (not ALU input)
\item
  ALU compares RS and RT register values
\end{itemize}

\textbf{RegWrite = 0:}

\begin{itemize}
\tightlist
\item
  Branch doesn't modify registers
\item
  Essential to prevent accidental writes
\item
  If =1, would corrupt register file
\end{itemize}

\subsubsection{11.5.4 Branch Target
Calculation}\label{branch-target-calculation}

\textbf{Word Offset to Byte Offset:}

\begin{itemize}
\tightlist
\item
  Immediate field: 100 (in instructions/words)
\item
  Sign extend to 32 bits: 0x00000064
\item
  Shift left by 2: 0x00000190 (multiply by 4)
\item
  Result: 400 bytes (100 instructions × 4 bytes/instruction)
\end{itemize}

\textbf{Branch Target Address:}

\begin{itemize}
\tightlist
\item
  Current PC + 4: Address of next sequential instruction
\item
  Offset: 400 bytes
\item
  Branch Target = (PC + 4) + 400
\end{itemize}

\textbf{Example:}

\begin{itemize}
\tightlist
\item
  Current instruction at address 1000
\item
  PC + 4 = 1004
\item
  Branch Target = 1004 + 400 = 1404
\item
  If branch taken: Next instruction at 1404
\item
  If branch not taken: Next instruction at 1004
\end{itemize}

\textbf{PCSrc Selection:}

PCSrc = Branch AND Zero = 1 AND (RS == RT ? 1 : 0)

If PCSrc = 1: PC ← Branch Target (1404) If PCSrc = 0: PC ← PC + 4 (1004)

\subsection{11.6 Load Word Instruction Detailed
Analysis}\label{load-word-instruction-detailed-analysis}

\subsubsection{11.6.1 Instruction Format}\label{instruction-format-2}

\textbf{Encoding Structure (32 bits):}

\begin{itemize}
\tightlist
\item
  \textbf{Bits 26-31}: Opcode = 100011 (35) - LW
\item
  \textbf{Bits 21-25}: RS (5 bits) - Base address register
\item
  \textbf{Bits 16-20}: RT (5 bits) - Destination register
\item
  \textbf{Bits 0-15}: Immediate (16 bits) - Address offset
\end{itemize}

\textbf{Example: LW \$8, 32(\$9)}

Encoding: 100011 01001 01000 0000000000100000 \textbar Opcode\textbar{}
RS \textbar{} RT \textbar{} Immediate \textbar{} \textbar{} 35
\textbar{} 9 \textbar{} 8 \textbar{} 32 \textbar{}

\textbf{Operation:} \texttt{\$8\ =\ Memory{[}\$9\ +\ 32{]}}

\subsubsection{11.6.2 Datapath Elements
Used}\label{datapath-elements-used-2}

Figure 3: Load Word Instruction Datapath

\textbf{Active Elements:}

\begin{itemize}
\tightlist
\item
  Instruction Memory: Fetch instruction
\item
  Program Counter \& PC+4 Adder
\item
  Register File: Read RS (base); Write RT (destination)
\item
  Sign Extender: Extend offset to 32 bits
\item
  Multiplexer (ALUSrc): Select immediate
\item
  ALU: Add base + offset
\item
  Data Memory: Read at calculated address
\item
  Multiplexer (MemtoReg): Select memory data
\item
  Multiplexer (RegDst): Select RT for write
\end{itemize}

\textbf{Inactive Elements:}

\begin{itemize}
\tightlist
\item
  Second register read (RT as source): Not used
\item
  Branch circuitry: Not used
\end{itemize}

\subsubsection{11.6.3 Control Signal Values for
LW}\label{control-signal-values-for-lw}

\textbf{Exercise Example: LW \$8, 32(\$9)}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Signal & Value & Reason \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
RegDst & 0 & Write to RT (bits 16-20), not RD \\
Branch & 0 & Not a branch instruction \\
MemRead & 1 & Reading from data memory \\
MemtoReg & 1 & Write memory data (not ALU result) \\
ALUOp & 00 & Perform ADD for address calculation \\
MemWrite & 0 & Not writing to memory (reading only) \\
ALUSrc & 1 & Add immediate offset (not register) \\
RegWrite & 1 & Write loaded data to destination register \\
\end{longtable}
}

\textbf{Detailed Explanations:}

\textbf{RegDst = 0:}

\begin{itemize}
\tightlist
\item
  I-type format: Destination in RT field
\item
  Multiplexer selects bits 16-20
\item
  RT = 01000 (register 8)
\item
  Different from R-type (RD field)
\end{itemize}

\textbf{Branch = 0:}

\begin{itemize}
\tightlist
\item
  Sequential execution
\item
  PC updated to PC + 4
\end{itemize}

\textbf{MemRead = 1:}

\begin{itemize}
\tightlist
\item
  Enable data memory read
\item
  Essential for memory timing
\item
  Memory outputs data at calculated address
\item
  If 0: Memory output undefined (ignored anyway)
\end{itemize}

\textbf{MemtoReg = 1:}

\begin{itemize}
\tightlist
\item
  Multiplexer selects memory data
\item
  Input 1: Data memory read output
\item
  Input 0: ALU result (address, not data!)
\item
  Must select memory data for load
\end{itemize}

\textbf{ALUOp = 00:}

\begin{itemize}
\tightlist
\item
  Address calculation requires ADD
\item
  Base address + offset
\item
  ALU Control = 0010 (ADD)
\end{itemize}

\textbf{MemWrite = 0:}

\begin{itemize}
\tightlist
\item
  Reading, not writing
\item
  Critical: Prevents memory corruption
\item
  If 1: Would write garbage to memory
\end{itemize}

\textbf{ALUSrc = 1:}

\begin{itemize}
\tightlist
\item
  Need immediate offset for address calculation
\item
  Multiplexer selects sign-extended immediate
\item
  Input 1: Sign-extended offset
\item
  Input 0: RT value (not used for address calc)
\end{itemize}

\textbf{RegWrite = 1:}

\begin{itemize}
\tightlist
\item
  Must write loaded data to RT
\item
  Data from memory → Register \$8
\item
  If 0: Data lost, load ineffective
\end{itemize}

\subsubsection{11.6.4 Critical Path for Load
Word}\label{critical-path-for-load-word}

\textbf{Longest Delay in Single-Cycle:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Instruction Memory read
\item
  Register File read (base address)
\item
  Sign Extension
\item
  ALU address calculation
\item
  Data Memory read
\item
  Register write setup
\end{enumerate}

\textbf{Load Word is the slowest instruction!}

\begin{itemize}
\tightlist
\item
  Determines minimum clock period
\item
  All other instructions must wait for this worst case
\item
  Major performance bottleneck
\end{itemize}

\subsection{11.7 Store Word Instruction Detailed
Analysis}\label{store-word-instruction-detailed-analysis}

\subsubsection{11.7.1 Instruction Format}\label{instruction-format-3}

\textbf{Encoding Structure (32 bits):}

\begin{itemize}
\tightlist
\item
  \textbf{Bits 26-31}: Opcode = 101011 (43) - SW
\item
  \textbf{Bits 21-25}: RS (5 bits) - Base address register
\item
  \textbf{Bits 16-20}: RT (5 bits) - Source data register
\item
  \textbf{Bits 0-15}: Immediate (16 bits) - Address offset
\end{itemize}

\textbf{Example: SW \$8, 32(\$9)}

Encoding: 101011 01001 01000 0000000000100000 \textbar Opcode\textbar{}
RS \textbar{} RT \textbar{} Immediate \textbar{} \textbar{} 43
\textbar{} 9 \textbar{} 8 \textbar{} 32 \textbar{}

\textbf{Operation:} \texttt{Memory{[}\$9\ +\ 32{]}\ =\ \$8}

\emph{Note: Fixed error in lecture (was ``\$32'', should be ``32'')}

\subsubsection{11.7.2 Datapath Elements
Used}\label{datapath-elements-used-3}

\textbf{Active Elements:}

\begin{itemize}
\tightlist
\item
  Instruction Memory
\item
  Program Counter \& PC+4 Adder
\item
  Register File: Read RS (base) AND RT (data source)
\item
  Sign Extender
\item
  Multiplexer (ALUSrc): Select immediate
\item
  ALU: Add base + offset
\item
  Data Memory: Write RT data at calculated address
\end{itemize}

\textbf{Inactive Elements:}

\begin{itemize}
\tightlist
\item
  Register Write: No register write
\item
  Memory Read: Writing, not reading
\item
  MemtoReg multiplexer: Output not used
\end{itemize}

\textbf{Key Difference from Load:}

\begin{itemize}
\tightlist
\item
  TWO register reads: RS for base, RT for data
\item
  Memory write instead of read
\item
  NO register write operation
\end{itemize}

\subsubsection{11.7.3 Control Signal Values for
SW}\label{control-signal-values-for-sw}

\textbf{Exercise Example: SW \$8, 32(\$9)}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Signal & Value & Reason \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
RegDst & X & Don't care (not writing to register) \\
Branch & 0 & Not a branch instruction \\
MemRead & 0 & Not reading from memory (writing) \\
MemtoReg & X & Don't care (not writing to register) \\
ALUOp & 00 & Perform ADD for address calculation \\
MemWrite & 1 & Writing to data memory \\
ALUSrc & 1 & Add immediate offset \\
RegWrite & 0 & Not writing to register file \\
\end{longtable}
}

\textbf{Detailed Explanations:}

\textbf{RegDst = X (Don't Care):}

\begin{itemize}
\tightlist
\item
  RegWrite = 0: No register write
\item
  Write address irrelevant
\item
  Could be 0 or 1, doesn't matter
\item
  Using X simplifies logic design
\end{itemize}

\textbf{CRITICAL: RegWrite = 0:}

\begin{itemize}
\tightlist
\item
  Must prevent register file write
\item
  \textbf{If RegWrite = 1:} Disaster!

  \begin{itemize}
  \tightlist
  \item
    Some register address fed to write port
  \item
    Either ALU result (address) or memory data (garbage, MemRead=0)
  \item
    Would corrupt random register
  \item
    Data integrity violated
  \end{itemize}
\end{itemize}

\textbf{Why It Matters:}

\begin{itemize}
\tightlist
\item
  Hardware operates in parallel
\item
  Multiplexers produce outputs even if not used
\item
  Without RegWrite = 0:

  \begin{itemize}
  \tightlist
  \item
    RegDst mux outputs some address
  \item
    MemtoReg mux outputs some data
  \item
    If RegWrite = 1: This garbage written to register!
  \end{itemize}
\item
  Control signal correctness essential
\end{itemize}

\textbf{MemRead = 0, MemWrite = 1:}

\begin{itemize}
\tightlist
\item
  Writing to memory, not reading
\item
  MemRead = 0: Memory read output undefined
\item
  MemWrite = 1: Memory accepts write data
\item
  Opposite of Load Word
\end{itemize}

\textbf{MemtoReg = X (Don't Care):}

\begin{itemize}
\tightlist
\item
  RegWrite = 0: Write data source irrelevant
\item
  Output not used
\item
  Even if wrong data selected, RegWrite prevents write
\end{itemize}

\textbf{ALUOp = 00:}

\begin{itemize}
\tightlist
\item
  Same as Load Word
\item
  Address calculation: ADD operation
\end{itemize}

\textbf{ALUSrc = 1:}

\begin{itemize}
\tightlist
\item
  Need immediate offset
\item
  Same as Load Word
\end{itemize}

\subsubsection{11.7.4 Important Lesson: Don't Care vs
Zero}\label{important-lesson-dont-care-vs-zero}

\textbf{Student Confusion:} \emph{``RegDst = 0 is not wrong, but best
answer is X''}

\textbf{Clarification:}

\begin{itemize}
\tightlist
\item
  \textbf{Functionally:} 0 works (doesn't cause error)
\item
  \textbf{Logically:} X is correct (truly doesn't matter)
\item
  \textbf{Design perspective:} X simplifies Boolean expressions
\item
  \textbf{Karnaugh map minimization:} X allows more groupings
\end{itemize}

\textbf{However:}

\begin{itemize}
\tightlist
\item
  RegWrite MUST be 0 (not X!)
\item
  MemWrite MUST be correct (not X!)
\item
  Read/Write enables are critical for data integrity
\end{itemize}

\subsection{11.8 Jump Instruction
Integration}\label{jump-instruction-integration}

\subsubsection{11.8.1 Instruction Format}\label{instruction-format-4}

\textbf{Encoding Structure (32 bits):}

\begin{itemize}
\tightlist
\item
  \textbf{Bits 26-31}: Opcode = 000010 (2) - J
\item
  \textbf{Bits 0-25}: Address (26 bits) - Jump target (word address)
\end{itemize}

\textbf{Alternative: JAL (Jump and Link)}

\begin{itemize}
\tightlist
\item
  Opcode = 000011 (3)
\item
  Used for function calls
\item
  Saves return address in register \$31
\end{itemize}

\textbf{Example: J 100}

Encoding: 000010 00000000000000000001100100 \textbar Opcode\textbar{}
Target Address \textbar{} \textbar{} 2 \textbar{} 100 \textbar{}

\textbf{Operation:}
\texttt{PC\ =\ \{PC+4{[}31:28{]},\ Address,\ 2\textquotesingle{}b00\}}

\subsubsection{11.8.2 Jump Target Address
Calculation}\label{jump-target-address-calculation}

\textbf{Word Address to Byte Address:}

\begin{itemize}
\tightlist
\item
  Target field: 26 bits (word address)
\item
  Shift left by 2: Append 2 zero bits
\item
  Result: 28-bit byte address
\end{itemize}

\textbf{Upper 4 Bits:}

\begin{itemize}
\tightlist
\item
  Take from PC+4 current value
\item
  Bits 31:28 of next sequential instruction
\item
  Preserves region (256 MB regions)
\item
  Jump within same region as current PC
\end{itemize}

\textbf{Concatenation:}

PC+4: {[}31:28{]} {[}27:2{]} {[}1:0{]} ↓ (ignored) Jump Target:
{[}31:28{]} {[}Target×4{]} {[}00{]} ↑ ↑ ↑ From From Append PC+4
instruction zeros

\textbf{Example:}

\begin{itemize}
\tightlist
\item
  PC = 0x10000000
\item
  PC+4 = 0x10000004
\item
  Target = 100 = 0x000064
\item
  Shift left 2: 0x000190
\item
  Upper 4 bits: 0x1
\item
  Jump Address: 0x10000190
\end{itemize}

\textbf{Limitation:}

\begin{itemize}
\tightlist
\item
  Can only jump within 28-bit range (256 MB)
\item
  Upper 4 bits fixed by current PC region
\item
  For larger jumps: Use jump register (JR) instruction
\end{itemize}

\subsubsection{11.8.3 Additional Datapath
Hardware}\label{additional-datapath-hardware}

Figure 4: Jump Instruction Datapath with Additional Hardware

\textbf{New Components:}

\textbf{Shift Left 2 (for jump):}

\begin{itemize}
\tightlist
\item
  Input: 26-bit target field
\item
  Output: 28-bit byte offset
\item
  Implementation: Wire routing (no actual shifter!)
\end{itemize}

\textbf{Concatenation Logic:}

\begin{itemize}
\tightlist
\item
  Input 1: PC+4 bits {[}31:28{]} (4 bits)
\item
  Input 2: Shifted target (28 bits)
\item
  Output: 32-bit jump address
\item
  Implementation: Wire concatenation
\end{itemize}

\textbf{New Multiplexer:}

\begin{itemize}
\tightlist
\item
  \textbf{Input 0}: Output from branch/sequential mux

  \begin{itemize}
  \tightlist
  \item
    Could be PC+4 or branch target
  \end{itemize}
\item
  \textbf{Input 1}: Jump target address (32 bits)
\item
  \textbf{Select}: Jump control signal
\item
  \textbf{Output}: Next PC value
\end{itemize}

\textbf{Original PC Source Mux:}

\begin{itemize}
\tightlist
\item
  Input 0: PC + 4
\item
  Input 1: Branch target
\item
  Select: PCSrc (Branch AND Zero)
\end{itemize}

\textbf{New Jump Mux (outer):}

\begin{itemize}
\tightlist
\item
  Input 0: Original mux output (PC+4 or branch target)
\item
  Input 1: Jump target
\item
  Select: Jump signal
\item
  Output: Final next PC value
\end{itemize}

\subsubsection{11.8.4 Jump Control Signal}\label{jump-control-signal}

\textbf{Jump Signal:}

\begin{itemize}
\tightlist
\item
  10th control output bit
\item
  Generated by Control Unit
\item
  Based on opcode = 2 (J) or 3 (JAL)
\end{itemize}

\textbf{Values:}

\begin{itemize}
\tightlist
\item
  Jump = 1: Select jump target
\item
  Jump = 0: Select sequential/branch
\end{itemize}

\textbf{Other Control Signals for Jump:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Signal & Value & Reason \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
RegDst & X & Don't care \\
Branch & 0 & Not a branch (different mechanism) \\
MemRead & 0 & Not accessing memory \\
MemtoReg & X & Don't care \\
ALUOp & XX & Don't care (ALU not used) \\
MemWrite & 0 & Not writing memory \\
ALUSrc & X & Don't care \\
RegWrite & 0 & Not writing register (J instruction) \\
Jump & 1 & This IS a jump instruction \\
\end{longtable}
}

\textbf{Note: JAL (Jump and Link) different:}

\begin{itemize}
\tightlist
\item
  RegWrite = 1 (saves return address)
\item
  RegDst = ? (special: write to \$31)
\item
  Additional logic needed for return address
\end{itemize}

\subsubsection{11.8.5 Complete Datapath with
Jump}\label{complete-datapath-with-jump}

\textbf{All Instruction Types Supported:}

\begin{itemize}
\tightlist
\item
  \textbf{R-type}: Arithmetic, logic, shift
\item
  \textbf{I-type}: Load, Store, Branch, Immediate arithmetic
\item
  \textbf{J-type}: Jump, Jump and Link
\end{itemize}

\textbf{Coverage:}

\begin{itemize}
\tightlist
\item
  95\%+ of MIPS ISA hardware
\item
  Complete single-cycle implementation
\item
  Additional variants (BNE, shifts, etc.) need minor additions
\end{itemize}

\textbf{Datapath Completeness:}

\begin{itemize}
\tightlist
\item
  Two memories: Instruction and Data
\item
  One ALU for computation
\item
  Multiple adders: PC+4, Branch target
\item
  Many multiplexers for data routing
\item
  Sign extender
\item
  Shift left 2 circuits (wire routing)
\item
  Control unit with 10 control signal bits
\end{itemize}

\subsection{11.9 Timing Analysis with Concrete
Delays}\label{timing-analysis-with-concrete-delays}

\subsubsection{11.9.1 Assumed Component
Delays}\label{assumed-component-delays}

\textbf{Delay Values (in nanoseconds):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Component & Delay & Notes \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Instruction Memory & 2 ns & Read instruction at PC address \\
Register File (Read) & 1 ns & Output data after address change \\
Register File (Write) & 1 ns & At clock edge (next cycle) \\
Sign Extender & \textasciitilde0 ns & Negligible (wire replication) \\
Multiplexers & \textasciitilde0 ns & Negligible compared to other
delays \\
ALU Operation & 2 ns & Arithmetic/logic/comparison \\
Data Memory (Read) & 2 ns & Output data after address provided \\
Data Memory (Write) & 2 ns & At clock edge (next cycle) \\
PC+4 Adder & 2 ns & Simple addition \\
Branch Target Adder & 2 ns & Addition with offset \\
\end{longtable}
}

\textbf{Assumptions:}

\begin{itemize}
\tightlist
\item
  Simplified for analysis
\item
  Real delays depend on technology, circuit design
\item
  Memory accesses typically slowest
\item
  Combinational logic relatively fast
\end{itemize}

\subsubsection{11.9.2 Critical Path
Analysis}\label{critical-path-analysis}

\textbf{Definition:}

\begin{itemize}
\tightlist
\item
  Longest delay path from clock edge to clock edge
\item
  Determines minimum clock period
\item
  All combinational logic between sequential elements
\end{itemize}

\textbf{Single-Cycle Constraint:}

\begin{itemize}
\tightlist
\item
  Entire instruction must complete in one clock cycle
\item
  Clock period ≥ Critical path delay
\item
  All instructions take same time (worst case)
\end{itemize}

\subsubsection{11.9.3 Load Word Instruction
Timing}\label{load-word-instruction-timing}

\textbf{Step-by-Step Delay Calculation:}

\textbf{Step 1: Instruction Fetch (2 ns)}

\begin{itemize}
\tightlist
\item
  Clock edge: PC updated
\item
  PC → Instruction Memory
\item
  Instruction Memory reads and outputs instruction
\item
  Delay: 2 ns
\item
  Running total: 2 ns
\end{itemize}

\textbf{Step 2: Register Read (1 ns)}

\begin{itemize}
\tightlist
\item
  Instruction decoded
\item
  RS field extracted
\item
  RS → Register File Read Address 1
\item
  Register File outputs base address
\item
  Delay: 1 ns
\item
  Running total: 2 + 1 = 3 ns
\end{itemize}

\textbf{Step 3: Sign Extension (\textasciitilde0 ns)}

\begin{itemize}
\tightlist
\item
  Immediate field extracted
\item
  Sign extended to 32 bits
\item
  Delay: Negligible
\item
  Running total: \textasciitilde3 ns
\end{itemize}

\textbf{Step 4: ALU Address Calculation (2 ns)}

\begin{itemize}
\tightlist
\item
  Base address + offset
\item
  ALU performs addition
\item
  Output: Memory address
\item
  Delay: 2 ns
\item
  Running total: 3 + 2 = 5 ns
\end{itemize}

\textbf{Step 5: Memory Read (2 ns)}

\begin{itemize}
\tightlist
\item
  ALU result → Data Memory address
\item
  MemRead = 1 asserted
\item
  Data Memory reads and outputs data
\item
  Delay: 2 ns
\item
  Running total: 5 + 2 = 7 ns
\end{itemize}

\textbf{Step 6: Register Write Setup (\textasciitilde0 ns)}

\begin{itemize}
\tightlist
\item
  Memory data → Register Write Data input
\item
  RT → Register Write Address
\item
  Ready for clock edge
\item
  Delay: Setup time negligible
\item
  Running total: \textasciitilde7 ns
\end{itemize}

\textbf{Clock Edge: Register Write (next cycle)}

\begin{itemize}
\tightlist
\item
  At next positive clock edge
\item
  Data written to register
\item
  Takes 1 ns but in next cycle
\end{itemize}

\textbf{Minimum Clock Period:} 7 nanoseconds\\
\textbf{Maximum Clock Frequency:} 1/7 ns ≈ 143 MHz

\textbf{Load Word is Critical Path!}

\begin{itemize}
\tightlist
\item
  Longest instruction in single-cycle design
\item
  Determines clock period for ALL instructions
\end{itemize}

\subsubsection{11.9.4 Store Word Instruction
Timing}\label{store-word-instruction-timing}

\textbf{Step-by-Step Delay:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Instruction Fetch:} 2 ns (total: 2 ns)
\item
  \textbf{Register Read:} 1 ns (total: 3 ns)

  \begin{itemize}
  \tightlist
  \item
    Read RS (base) AND RT (data)
  \end{itemize}
\item
  \textbf{Sign Extension:} \textasciitilde0 ns (total: 3 ns)
\item
  \textbf{ALU Address Calculation:} 2 ns (total: 5 ns)
\item
  \textbf{Memory Write Setup:} \textasciitilde0 ns (total: 5 ns)

  \begin{itemize}
  \tightlist
  \item
    Address and data ready at memory inputs
  \end{itemize}
\end{enumerate}

\textbf{Clock Edge: Memory Write (end of cycle)}

\begin{itemize}
\tightlist
\item
  Data written to memory at clock edge
\item
  Takes 2 ns but next instruction fetch also 2 ns
\item
  Next instruction register read starts after 3 ns total
\item
  Memory write completes before register read needs data
\item
  No conflict
\end{itemize}

\textbf{Minimum Time Required:} 5 nanoseconds

\textbf{Note:}

\begin{itemize}
\tightlist
\item
  Faster than Load Word (no memory read delay)
\item
  But must use 7 ns clock period anyway (single-cycle)
\item
  Wastes 2 ns per Store instruction
\end{itemize}

\subsubsection{11.9.5 Arithmetic Instruction Timing (ADD, SUB, AND,
OR)}\label{arithmetic-instruction-timing-add-sub-and-or}

\textbf{Step-by-Step Delay:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Instruction Fetch:} 2 ns (total: 2 ns)
\item
  \textbf{Register Read:} 1 ns (total: 3 ns)

  \begin{itemize}
  \tightlist
  \item
    Read RS and RT
  \end{itemize}
\item
  \textbf{ALU Operation:} 2 ns (total: 5 ns)

  \begin{itemize}
  \tightlist
  \item
    Perform arithmetic/logic operation
  \end{itemize}
\item
  \textbf{Register Write Setup:} \textasciitilde0 ns (total: 5 ns)

  \begin{itemize}
  \tightlist
  \item
    ALU result ready at register write data input
  \end{itemize}
\end{enumerate}

\textbf{Clock Edge: Register Write}

\begin{itemize}
\tightlist
\item
  Result written to RD
\end{itemize}

\textbf{Minimum Time Required:} 5 nanoseconds

\textbf{Efficiency Loss:}

\begin{itemize}
\tightlist
\item
  Could run at 5 ns clock period
\item
  Forced to wait 7 ns (Load Word limitation)
\item
  Wastes 2 ns = 28.6\% time wasted per R-type instruction
\end{itemize}

\subsubsection{11.9.6 Branch Instruction
Timing}\label{branch-instruction-timing}

\textbf{Step-by-Step Delay:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Instruction Fetch:} 2 ns (total: 2 ns)
\item
  \textbf{Register Read:} 1 ns (total: 3 ns)

  \begin{itemize}
  \tightlist
  \item
    Read RS and RT for comparison
  \end{itemize}
\item
  \textbf{ALU Comparison:} 2 ns (total: 5 ns)

  \begin{itemize}
  \tightlist
  \item
    Subtract RS - RT
  \item
    Generate Zero flag
  \end{itemize}
\item
  \textbf{Branch Target Calculation:} 2 ns (parallel with ALU)

  \begin{itemize}
  \tightlist
  \item
    Sign extend offset: \textasciitilde0 ns
  \item
    Shift left 2: \textasciitilde0 ns (wire routing)
  \item
    Add to PC+4: 2 ns
  \item
    Can happen in parallel with ALU operation!
  \end{itemize}
\item
  \textbf{PC Update Setup:} \textasciitilde0 ns (total: 5 ns)

  \begin{itemize}
  \tightlist
  \item
    Zero flag + Branch → PCSrc
  \item
    Multiplexer selects next PC
  \item
    Ready for clock edge
  \end{itemize}
\end{enumerate}

\textbf{Minimum Time Required:} 5 nanoseconds

\textbf{Key Insight:}

\begin{itemize}
\tightlist
\item
  Branch target calculation parallel to ALU
\item
  PC+4 already available from fetch stage
\item
  No memory access needed
\item
  Fast like R-type
\end{itemize}

\subsubsection{11.9.7 Jump Instruction
Timing}\label{jump-instruction-timing}

\textbf{Step-by-Step Delay:}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Instruction Fetch:} 2 ns (total: 2 ns)

  \begin{itemize}
  \tightlist
  \item
    Also calculates PC+4 in parallel
  \end{itemize}
\item
  \textbf{Jump Target Calculation:} \textasciitilde0 ns

  \begin{itemize}
  \tightlist
  \item
    Extract 26-bit target
  \item
    Shift left 2: Wire routing, \textasciitilde0 ns
  \item
    Concatenate with PC+4{[}31:28{]}: Wire connection, \textasciitilde0
    ns
  \item
    No ALU, no memory, no registers!
  \end{itemize}
\item
  \textbf{PC Update Setup:} \textasciitilde0 ns (total: 2 ns)
\end{enumerate}

\textbf{Minimum Time Required:} 2 nanoseconds

\textbf{Fastest Instruction:}

\begin{itemize}
\tightlist
\item
  Only instruction fetch needed
\item
  Jump target calculation: Wire operations only
\item
  No sequential dependencies
\item
  Wastes 5 ns waiting for clock period!
\end{itemize}

\subsubsection{11.9.8 Timing Summary Table}\label{timing-summary-table}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Instruction Type & Time Required & Wasted Time & Efficiency \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Load Word (LW) & 7 ns & 0 ns & 100\% \\
Store Word (SW) & 5 ns & 2 ns & 71.4\% \\
R-type (ADD, etc.) & 5 ns & 2 ns & 71.4\% \\
Branch (BEQ) & 5 ns & 2 ns & 71.4\% \\
Jump (J) & 2 ns & 5 ns & 28.6\% \\
\end{longtable}
}

\textbf{Clock Period (Single-Cycle):} 7 ns (determined by LW)\\
\textbf{Clock Frequency:} \textasciitilde143 MHz

\textbf{Performance Impact:}

\begin{itemize}
\tightlist
\item
  Most instructions waste time
\item
  Only Load Word fully utilizes clock cycle
\item
  Tremendous inefficiency
\end{itemize}

\subsection{11.10 Performance Analysis}\label{performance-analysis}

\subsubsection{11.10.1 Program Composition
Example}\label{program-composition-example}

\textbf{Typical MIPS Program Profile:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Instruction Type & Percentage & Time if Variable & Time (Fixed 7ns) \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Arithmetic & 48\% & 5 ns & 7 ns \\
Load Word & 22\% & 7 ns & 7 ns \\
Store Word & 11\% & 5 ns & 7 ns \\
Branch & 19\% & 5 ns & 7 ns \\
\end{longtable}
}

\subsubsection{11.10.2 Average Time
Calculation}\label{average-time-calculation}

\textbf{Variable Time (Ideal):}

Average = (0.48 × 5) + (0.22 × 7) + (0.11 × 5) + (0.19 × 5) = 2.40 +
1.54 + 0.55 + 0.95 = 5.44 ns per instruction

\textbf{Single-Cycle (Actual):}

Average = 7 ns per instruction (all instructions)

\textbf{Performance Loss:}

Overhead = 7 - 5.44 = 1.56 ns per instruction Efficiency = 5.44 / 7 =
77.7\% Waste = 22.3\% of time

\subsubsection{11.10.3 Critical Path
Problem}\label{critical-path-problem}

\textbf{Critical Path Determination:}

\begin{itemize}
\tightlist
\item
  Load Word uses most datapath elements
\item
  Sequential dependencies:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    Instruction Memory
  \item
    Register File
  \item
    ALU
  \item
    Data Memory
  \item
    (Register Write in next cycle)
  \end{enumerate}
\end{itemize}

\textbf{Design Principle Violation:}

\begin{itemize}
\tightlist
\item
  \textbf{``Make the common case fast''}
\item
  Common case: Arithmetic instructions (48\%)
\item
  Slow case (Load Word) determines speed
\item
  Common case forced to slow down
\item
  Design is inefficient
\end{itemize}

\subsubsection{11.10.4 Clock Period
Inflexibility}\label{clock-period-inflexibility}

\textbf{Single-Cycle Constraint:}

\begin{itemize}
\tightlist
\item
  Clock period MUST be constant
\item
  Cannot vary by instruction
\item
  Must accommodate worst case (slowest instruction)
\item
  All faster instructions penalized
\end{itemize}

\textbf{Implications:}

\begin{itemize}
\tightlist
\item
  Arithmetic: Could run at 143 MHz, forced to 143 MHz ✓
\item
  Load: Needs 143 MHz, gets 143 MHz ✓
\item
  Jump: Could run at 500 MHz, forced to 143 MHz ✗
\end{itemize}

\textbf{Efficiency by Instruction:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Instruction & Efficiency & Waste \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Jump & 28.6\% & 71.4\% \\
Arithmetic & 71.4\% & 28.6\% \\
Store & 71.4\% & 28.6\% \\
Branch & 71.4\% & 28.6\% \\
Load & 100.0\% & 0\% \\
\end{longtable}
}

\subsection{11.11 Path to Better Performance: Multi-Cycle
Design}\label{path-to-better-performance-multi-cycle-design}

\subsubsection{11.11.1 Multi-Cycle Concept}\label{multi-cycle-concept}

\textbf{Basic Idea:}

\begin{itemize}
\tightlist
\item
  Break instruction execution into multiple stages
\item
  Each stage completes in one (shorter) clock cycle
\item
  Different instructions use different number of cycles
\item
  Only use stages actually needed
\end{itemize}

\textbf{Advantages:}

\begin{itemize}
\tightlist
\item
  Shorter clock period (faster clock)
\item
  Instructions take only time they need
\item
  Better average performance
\item
  More efficient resource utilization
\end{itemize}

\subsubsection{11.11.2 Stage Division}\label{stage-division}

\textbf{Typical Stages:}

\textbf{Stage 1: Instruction Fetch (IF)}

\begin{itemize}
\tightlist
\item
  Read from instruction memory
\item
  Update PC to PC+4
\item
  Store instruction in register
\end{itemize}

\textbf{Stage 2: Instruction Decode (ID)}

\begin{itemize}
\tightlist
\item
  Decode opcode
\item
  Read registers
\item
  Generate control signals
\item
  Sign extend immediate
\end{itemize}

\textbf{Stage 3: Execute (EX)}

\begin{itemize}
\tightlist
\item
  ALU operation
\item
  Or address calculation
\item
  Or branch comparison
\end{itemize}

\textbf{Stage 4: Memory Access (MEM)}

\begin{itemize}
\tightlist
\item
  Read from data memory (if load)
\item
  Write to data memory (if store)
\item
  Or skip this stage
\end{itemize}

\textbf{Stage 5: Write-Back (WB)}

\begin{itemize}
\tightlist
\item
  Write result to register file
\item
  Or skip if no write needed
\end{itemize}

\textbf{Not All Instructions Use All Stages:}

\begin{itemize}
\tightlist
\item
  \textbf{R-type}: IF, ID, EX, WB (skip MEM) = 4 cycles
\item
  \textbf{Load}: IF, ID, EX, MEM, WB (all stages) = 5 cycles
\item
  \textbf{Store}: IF, ID, EX, MEM (skip WB) = 4 cycles
\item
  \textbf{Branch}: IF, ID, EX (skip MEM, WB) = 3 cycles
\item
  \textbf{Jump}: IF, ID (skip EX, MEM, WB) = 2 cycles
\end{itemize}

\subsubsection{11.11.3 Clock Period in
Multi-Cycle}\label{clock-period-in-multi-cycle}

\textbf{Determining Clock Period:}

\begin{itemize}
\tightlist
\item
  Clock period = Longest stage delay
\item
  NOT longest instruction delay
\item
  Much shorter than single-cycle
\end{itemize}

\textbf{Example Stage Delays:}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}ll@{}}
\toprule\noalign{}
Stage & Delay \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
IF (Instr Memory) & 2 ns \\
ID (Register Read) & 1 ns \\
EX (ALU) & 2 ns \\
MEM (Data Memory) & 2 ns \\
WB (Register Write) & 1 ns \\
\end{longtable}
}

\textbf{Longest Stage:} 2 ns\\
\textbf{Clock Period:} 2 ns (vs 7 ns single-cycle)\\
\textbf{Clock Frequency:} 500 MHz (vs 143 MHz single-cycle)

\subsubsection{11.11.4 Performance
Comparison}\label{performance-comparison}

\textbf{Single-Cycle:}

All instructions: 1 cycle × 7 ns = 7 ns

\textbf{Multi-Cycle (with 2 ns clock):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Instruction & Cycles & Time \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Arithmetic & 4 & 8 ns \\
Load & 5 & 10 ns \\
Store & 4 & 8 ns \\
Branch & 3 & 6 ns \\
Jump & 2 & 4 ns \\
\end{longtable}
}

\textbf{Weighted Average (same program profile):}

Average = (0.48 × 8) + (0.22 × 10) + (0.11 × 8) + (0.19 × 6) = 3.84 +
2.20 + 0.88 + 1.14 = 8.06 ns per instruction

\textbf{Wait, That's Worse!}

\begin{itemize}
\tightlist
\item
  Multi-cycle: 8.06 ns average
\item
  Single-cycle: 7 ns always
\item
  Multi-cycle slower?!
\end{itemize}

\textbf{Resolution:}

\begin{itemize}
\tightlist
\item
  Example delays assumed equal stage times
\item
  In reality, stages have different delays
\item
  Need to balance stage delays
\item
  Goal: Make all stages approximately equal
\item
  Then multi-cycle becomes efficient
\end{itemize}

\textbf{Ideal Multi-Cycle (balanced 1.4 ns stages):}

{\def\LTcaptype{none} % do not increment counter
\begin{longtable}[]{@{}lll@{}}
\toprule\noalign{}
Instruction & Cycles & Time \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
Arithmetic & 4 & 5.6 ns \\
Load & 5 & 7.0 ns \\
Store & 4 & 5.6 ns \\
Branch & 3 & 4.2 ns \\
\end{longtable}
}

Average = (0.48 × 5.6) + (0.22 × 7.0) + (0.11 × 5.6) + (0.19 × 4.2) =
2.69 + 1.54 + 0.62 + 0.80 = 5.65 ns per instruction

Speedup = 7 / 5.65 = 1.24× faster

\subsubsection{11.11.5 Design Challenge}\label{design-challenge}

\textbf{Stage Balancing:}

\begin{itemize}
\tightlist
\item
  Goal: Roughly equal delay per stage
\item
  Challenge: Memory slower than ALU
\item
  Memory stage limits clock period
\item
  Need techniques:

  \begin{itemize}
  \tightlist
  \item
    Faster memory
  \item
    Cache memory (next topic)
  \item
    Pipeline (next lecture)
  \end{itemize}
\end{itemize}

\textbf{Resource Reuse:}

\begin{itemize}
\tightlist
\item
  Single ALU used across multiple cycles
\item
  Single memory port can be reused
\item
  Fewer hardware resources needed
\item
  More control complexity (FSM needed)
\end{itemize}

\subsection{11.12 Preview: Pipelining}\label{preview-pipelining}

\subsubsection{11.12.1 Next Step Beyond
Multi-Cycle}\label{next-step-beyond-multi-cycle}

\textbf{Pipelining Concept:}

\begin{itemize}
\tightlist
\item
  Multiple instructions in flight simultaneously
\item
  Each instruction at different stage
\item
  Like assembly line
\item
  \textbf{Stage 1:} Fetch instruction A
\item
  \textbf{Stage 2:} Decode A, Fetch B
\item
  \textbf{Stage 3:} Execute A, Decode B, Fetch C
\item
  \textbf{Stage 4:} Memory A, Execute B, Decode C, Fetch D
\item
  \textbf{Stage 5:} Write A, Memory B, Execute C, Decode D, Fetch E
\end{itemize}

\textbf{Benefits:}

\begin{itemize}
\tightlist
\item
  One instruction completes per cycle (like single-cycle)
\item
  But clock period short (like multi-cycle)
\item
  Best of both worlds
\item
  Dramatic performance improvement
\end{itemize}

\textbf{Challenges (Covered Next Lecture):}

\begin{itemize}
\tightlist
\item
  Hazards: Data dependencies between instructions
\item
  Control hazards: Branches affect pipeline
\item
  Structural hazards: Resource conflicts
\item
  Need forwarding and stall logic
\item
  More complex control
\end{itemize}

\subsubsection{11.12.2 Coming Next}\label{coming-next}

\textbf{Topics:}

\begin{itemize}
\tightlist
\item
  Pipelined datapath design
\item
  Hazard detection and resolution
\item
  Forwarding (bypassing)
\item
  Branch prediction
\item
  Performance analysis
\item
  MIPS pipeline implementation
\end{itemize}

\subsection{Key Takeaways}\label{key-takeaways}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Single-cycle design executes each instruction in one clock
  cycle}, with clock period determined by the slowest instruction (Load
  Word at 7 ns).
\item
  \textbf{Control unit generates signals based on opcode}, orchestrating
  datapath operations for R-type, Load, Store, Branch, and Jump
  instructions.
\item
  \textbf{Load Word is the critical path} (Instruction Fetch → Register
  Read → ALU → Memory Read → Register Write), determining minimum clock
  period.
\item
  \textbf{Jump instruction uses PC{[}31:28{]}} concatenated with shifted
  immediate to form 32-bit target address, enabling 256 MB jump range.
\item
  \textbf{Control signals must prevent data corruption}, with RegWrite=0
  for Store and Branch to avoid unintended register modifications.
\item
  \textbf{``Don't care'' values (X) simplify control logic}, allowing
  optimization when signals don't affect instruction outcome.
\item
  \textbf{Hardware operates concurrently}, not sequentially---multiple
  operations happen simultaneously within each clock cycle.
\item
  \textbf{Performance inefficiency drives design evolution}, as most
  instructions finish early but must wait for full clock period.
\item
  \textbf{Resource utilization varies dramatically}, with arithmetic
  instructions using \textasciitilde43\% of clock period while Load uses
  100\%.
\item
  \textbf{Timing analysis reveals optimization opportunities}, showing
  that memory access dominates critical path (4 ns of 7 ns total).
\item
  \textbf{Write operations occur at clock edge}, ensuring data stability
  and preventing race conditions in sequential logic.
\item
  \textbf{Branch target calculation happens in parallel} with ALU
  comparison, optimizing branch instruction timing.
\item
  \textbf{Sign extension is effectively instantaneous} (combinational
  logic), adding negligible delay to critical path.
\item
  \textbf{Clock period sets maximum frequency} (\textasciitilde143 MHz
  for 7 ns period), directly impacting overall processor performance.
\item
  \textbf{Common case (arithmetic) runs slowly}, violating fundamental
  design principle of making common case fast.
\item
  \textbf{Stage division concept emerges from timing analysis},
  suggesting multi-cycle implementation could improve efficiency.
\item
  \textbf{Control signal truth tables systematically define behavior},
  mapping each instruction to specific control patterns.
\item
  \textbf{PC update mechanisms vary by instruction type}, using PC+4,
  branch target, or jump target based on control signals.
\item
  \textbf{Data memory access only for Load/Store}, with MemRead and
  MemWrite controlling when memory participates in execution.
\item
  \textbf{Performance analysis quantifies inefficiency}, providing
  concrete motivation for pipelined processor designs in subsequent
  lectures.
\end{enumerate}

\subsection{Summary}\label{summary}

The single-cycle MIPS processor represents a complete, functioning
implementation where each instruction executes in exactly one clock
cycle. While conceptually straightforward and easy to understand, the
design reveals fundamental performance limitations that drive modern
processor architecture evolution. The critical path analysis shows Load
Word requiring 7 nanoseconds while simpler instructions like arithmetic
operations complete in just 3 nanoseconds, forcing all instructions to
wait for the slowest operation. This inefficiency---with most
instructions utilizing less than half the available clock
period---violates the crucial design principle of ``making the common
case fast.'' The systematic control signal analysis demonstrates how the
control unit orchestrates datapath operations for different instruction
types (R-type, Load, Store, Branch, Jump), with careful attention to
preventing data corruption through proper RegWrite and MemWrite signals.
The jump instruction introduces pseudo-direct addressing, concatenating
PC upper bits with shifted immediate for 256 MB addressability. While
the single-cycle design provides essential conceptual foundation for
understanding processor operation, the detailed timing analysis and
resource utilization metrics clearly motivate the need for more
sophisticated approaches---multi-cycle processors that divide execution
into variable-length stages, and pipelined processors that overlap
instruction execution for dramatically improved throughput. These
performance limitations aren't flaws but rather inevitable consequences
of the single-cycle constraint, establishing why modern processors
universally adopt pipelining despite the additional complexity it
introduces.
