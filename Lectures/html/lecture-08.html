<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture 8: Memory Access - Lectures on Computer Architecture</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
            onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true},{left: '$', right: '$', display: false}]});"></script>
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-asm6502.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
</head>
<body>
    <header class="lecture-header">
        <div class="container">
            <a href="../../index.html" class="back-link">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                Back to All Lectures
            </a>
            <h1 class="lecture-title">Lecture 8: Memory Access</h1>
            <p class="lecture-meta">Lectures on Computer Architecture</p>
        </div>
    </header>

    <main class="lecture-content-area container">
        <div class="content-body">
            <!-- Video Section -->
            <div class="video-container">
                <div class="video-thumbnail">
                    <a href="https://www.youtube.com/watch?v=IxaTbKoCr1Y" target="_blank" class="video-play-overlay">
                        <img src="https://img.youtube.com/vi/IxaTbKoCr1Y/maxresdefault.jpg" 
                             alt="Lecture 8 Video Thumbnail"
                             onerror="this.src='https://img.youtube.com/vi/IxaTbKoCr1Y/hqdefault.jpg'">
                        <div class="play-button">
                            <svg width="68" height="48" viewBox="0 0 68 48" fill="none">
                                <path d="M66.52 7.74c-.78-2.93-2.49-5.41-5.42-6.19C55.79.13 34 0 34 0S12.21.13 6.9 1.55c-2.93.78-4.63 3.26-5.42 6.19C.06 13.05 0 24 0 24s.06 10.95 1.48 16.26c.78 2.93 2.49 5.41 5.42 6.19C12.21 47.87 34 48 34 48s21.79-.13 27.1-1.55c2.93-.78 4.64-3.26 5.42-6.19C67.94 34.95 68 24 68 24s-.06-10.95-1.48-16.26z" fill="red"/>
                                <path d="M45 24L27 14v20" fill="white"/>
                            </svg>
                        </div>
                    </a>
                </div>
                <div class="video-info">
                    <p class="video-notice">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="16" x2="12" y2="12"></line>
                            <line x1="12" y1="8" x2="12.01" y2="8"></line>
                        </svg>
                        Click the thumbnail above to watch the video lecture on YouTube
                    </p>
                </div>
            </div>

            
<em>By Dr. Kisaru Liyanage</em>

<h2>8.1 Introduction</h2>

<p>This lecture explores character data handling, string operations, and the compilation/linking/loading process. We examine byte and half-word memory operations, implement string manipulation functions, use library functions like scanf and printf, and understand how programs transform from source code to executable binaries. These topics bridge high-level programming concepts and low-level assembly implementation, essential for systems programming and understanding program execution.</p>


<h2>8.2 Character Data and Encoding</h2>

<h3>8.2.1 ASCII Encoding</h3>

<p><strong>Basic 7-Bit Standard</strong></p>

<ul>
<li>Represents 128 characters using 7 bits (2⁷ = 128)</li>
<li>95 graphic symbols (printable): A-Z, a-z, 0-9, punctuation</li>
<li>33 control symbols: newline ('\\n'), tab ('\\t'), null ('\\0')</li>
<li>Most basic and widely used encoding</li>
</ul>

<p><strong>ASCII Examples</strong></p>
<pre><code>'A' = 65 (0x41)
'a' = 97 (0x61)
'0' = 48 (0x30)
'\n' = 10 (0x0A)
'\0' = 0 (0x00)  ; null terminator</code></pre>


<h3>8.2.2 Latin-1 Encoding</h3>

<p><strong>Extended 8-Bit Standard</strong></p>

<ul>
<li>Supports 256 characters using 8 bits (2⁸ = 256)</li>
<li>Includes all ASCII characters (first 128)</li>
<li>Adds 96 additional graphic characters</li>
<li>European language support (accented characters)</li>
</ul>

<h3>8.2.3 Unicode Encoding</h3>

<p><strong>Modern Universal Standard</strong></p>

<ul>
<li>Uses 32-bit character set (2³² possible characters)</li>
<li>Can represent most world alphabets and symbols</li>
<li>Used in modern languages (Java, C++, Python 3)</li>
<li>Variable-length encodings: UTF-8, UTF-16</li>
<li>UTF-8: 1-4 bytes per character (backward compatible with ASCII)</li>
</ul>

<p><strong>Why Unicode?</strong></p>

<ul>
<li>Global language support</li>
<li>Emoji and special symbols</li>
<li>Mathematical and technical symbols</li>
<li>Historical scripts and languages</li>
</ul>

<h2>8.3 Byte Load/Store Operations</h2>

<h3>8.3.1 Load Register Byte (LDRB)</h3>

<p><strong>Syntax</strong></p>
<pre><code class="language-asm6502">LDRB Rd, [Rn, #offset]   ; Load byte from memory</code></pre>


<p><strong>Operation</strong></p>

<ul>
<li>Reads 8 bits (1 byte) from memory</li>
<li>Fills upper 24 bits of register with zeros (zero-extension)</li>
<li>Lower 8 bits contain the loaded byte</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">; Memory[0x1000] = 0x42 ('B')
LDR R1, =0x1000
LDRB R0, [R1]
; R0 = 0x00000042</code></pre>


<p><strong>Use Cases</strong></p>

<ul>
<li>Loading single characters</li>
<li>Reading byte arrays</li>
<li>Accessing packed data structures</li>
<li>I/O port access</li>
</ul>

<h3>8.3.2 Store Register Byte (STRB)</h3>

<p><strong>Syntax</strong></p>
<pre><code class="language-asm6502">STRB Rd, [Rn, #offset]   ; Store byte to memory</code></pre>

<p><strong>Operation</strong></p>

<ul>
<li>Writes lower 8 bits of register to memory</li>
<li>Upper 24 bits of register ignored</li>
<li>Only affects 1 byte in memory</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">MOV R0, #0x41        ; 'A'
LDR R1, =0x2000
STRB R0, [R1]        ; Memory[0x2000] = 0x41</code></pre>


<h3>8.3.3 Load Register Signed Byte (LDRSB)</h3>

<p><strong>Syntax</strong></p>
<pre><code class="language-asm6502">LDRSB Rd, [Rn, #offset]  ; Load signed byte</code></pre>

<p><strong>Operation</strong></p>

<ul>
<li>Loads 8 bits from memory</li>
<li>Replicates sign bit (bit 7) to fill upper 24 bits</li>
<li>Sign-extension preserves signed value</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">; Memory[0x1000] = 0xFE (-2 in signed byte)
LDR R1, =0x1000
LDRSB R0, [R1]
; R0 = 0xFFFFFFFE (-2 in 32-bit signed)
; Memory[0x1001] = 0x7F (+127)
LDRSB R0, [R1, #1]
; R0 = 0x0000007F (+127)</code></pre>

<p><strong>When to Use</strong></p>

<ul>
<li>Loading signed characters (int8_t)</li>
<li>Temperature values</li>
<li>Signed offsets or deltas</li>
</ul>

<h3>8.3.4 Memory Alignment</h3>

<p><strong>LDRB Advantages</strong></p>

<ul>
<li>Can access ANY byte address</li>
<li>No alignment requirement</li>
<li>Example: addresses 0, 1, 2, 3, 4, 5...</li>
</ul>

<p><strong>LDR Requirement</strong></p>

<ul>
<li>Must use word-aligned addresses (multiples of 4)</li>
<li>Valid addresses: 0, 4, 8, 12, 16...</li>
<li>Invalid: 1, 2, 3, 5, 6, 7, 9...</li>
<li>Unaligned access causes errors or performance penalties</li>
</ul>

<h2>8.4 Half-Word Load/Store Operations</h2>

<h3>8.4.1 Load Register Half-word (LDRH)</h3>

<p><strong>Syntax</strong></p>
<pre><code class="language-asm6502">LDRH Rd, [Rn, #offset]   ; Load 16 bits</code></pre>

<p><strong>Operation</strong></p>

<ul>
<li>Loads 16 bits (2 bytes) from memory</li>
<li>Fills upper 16 bits with zeros (zero-extension)</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">; Memory[0x1000-0x1001] = 0xABCD
LDR R1, =0x1000
LDRH R0, [R1]
; R0 = 0x0000ABCD</code></pre>

<p><strong>Use Cases</strong></p>

<ul>
<li>Loading 16-bit integers (short)</li>
<li>Unicode characters (UTF-16)</li>
<li>16-bit data types</li>
</ul>

<h3>8.4.2 Store Register Half-word (STRH)</h3>

<p><strong>Syntax</strong></p>
<pre><code class="language-asm6502">STRH Rd, [Rn, #offset]   ; Store 16 bits</code></pre>

<p><strong>Operation</strong></p>

<ul>
<li>Writes lower 16 bits of register to memory</li>
<li>Upper 16 bits ignored</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">MOV R0, #0x1234
LDR R1, =0x2000
STRH R0, [R1]
; Memory[0x2000-0x2001] = 0x1234</code></pre>


<h3>8.4.3 Load Register Signed Half-word (LDRSH)</h3>

<p><strong>Syntax</strong></p>
<pre><code class="language-asm6502">LDRSH Rd, [Rn, #offset]  ; Load signed 16-bit</code></pre>

<p><strong>Operation</strong></p>

<ul>
<li>Loads 16 bits from memory</li>
<li>Replicates sign bit (bit 15) to upper 16 bits</li>
<li>Sign-extension</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">; Memory = 0x8000 (-32768 as signed 16-bit)
LDRSH R0, [R1]
; R0 = 0xFFFF8000 (-32768 as signed 32-bit)</code></pre>


<h2>8.5 String Copy Example (strcpy)</h2>

<h3>8.5.1 C Implementation</h3>

<p><strong>Code</strong></p>
<pre><code class="language-c">void strcpy(char x[], char y[]) {
    int i = 0;
    while ((x[i] = y[i]) != '\0') {
        i++;
    }
}</code></pre>

<p><strong>Algorithm</strong></p>

<ol>
<li>Copy characters from y to x one at a time</li>
<li>Stop when null terminator ('\\0') encountered</li>
<li>Null terminator also copied</li>
</ol>

<h3>8.5.2 ARM Assembly Implementation</h3>

<p><strong>Register Allocation</strong></p>
<pre><code>R0: Base address of x (destination)
R1: Base address of y (source)
R4: Loop counter i
R2: Address of y[i]
R3: Value of y[i]
R12: Address of x[i]</code></pre>

<p><strong>Complete Assembly</strong></p>
<pre><code class="language-asm6502">strcpy:
    ; Prologue: Save R4 (must preserve)
    SUB SP, SP, #4
    STR R4, [SP, #0]
    ; Initialize counter
    MOV R4, #0           ; i = 0
loop:
    ; Calculate address of y[i]
    ADD R2, R4, R1       ; R2 = y + i
    ; Load y[i]
    LDRB R3, [R2, #0]    ; R3 = y[i]
    ; Calculate address of x[i]
    ADD R12, R4, R0      ; R12 = x + i
    ; Store to x[i]
    STRB R3, [R12, #0]   ; x[i] = y[i]
    ; Check for null terminator
    CMP R3, #0           ; Is y[i] == '\0'?
    BEQ done             ; If yes, exit loop
    ; Increment counter
    ADD R4, R4, #1       ; i++
    B loop               ; Continue loop
done:
    ; Epilogue: Restore R4
    LDR R4, [SP, #0]
    ADD SP, SP, #4
    MOV PC, LR           ; Return</code></pre>


<h3>8.5.3 Key Points</h3>

<p><strong>Why LDRB/STRB?</strong></p>

<ul>
<li>Strings are char arrays (8-bit elements)</li>
<li>Must use byte operations</li>
</ul>

<p><strong>Register Preservation</strong></p>

<ul>
<li>R4 must be saved/restored (callee-saved)</li>
<li>R12 doesn't need preservation (scratch register)</li>
</ul>

<p><strong>Offsets Are Immediate</strong></p>

<ul>
<li><code>[R2, #0]</code> uses immediate offset (hash symbol)</li>
<li>Cannot use <code>[R2, R3]</code> directly without proper syntax</li>
</ul>

<h2>8.6 Library Functions: scanf and printf</h2>

<h3>8.6.1 scanf Function</h3>

<p><strong>Purpose</strong></p>

<ul>
<li>Read input from standard input (keyboard)</li>
<li>Parse formatted input</li>
</ul>

<p><strong>C Signature</strong></p>

<pre><code class="language-c">int scanf(const char *format, ...);</code></pre>

<p><strong>Arguments</strong></p>

<ul>
<li>R0: Address of format string ("%d", "%c", "%s", etc.)</li>
<li>R1: Address where to store input (NOT the value!)</li>
<li>R2, R3: Additional addresses for more inputs</li>
</ul>

<p><strong>Example: Read Integer</strong></p>

<p><strong>C Code</strong></p>
<pre><code class="language-c">int x;
scanf("%d", &x);  // Note: &x (address of x)</code></pre>

<p><strong>ARM Assembly</strong></p>
<pre><code class="language-asm6502">.data
formatS: .asciz "%d"
.text
    SUB SP, SP, #4       ; Space for x
    LDR R0, =formatS     ; R0 = address of "%d"
    MOV R1, SP           ; R1 = address where to store
    BL scanf
    LDR R2, [SP, #0]     ; R2 = x</code></pre>


<h3>8.6.2 printf Function</h3>

<p><strong>Purpose</strong></p>

<ul>
<li>Print output to standard output (screen)</li>
<li>Format and display data</li>
</ul>

<p><strong>C Signature</strong></p>

<pre><code class="language-c">int printf(const char *format, ...);</code></pre>

<p><strong>Arguments</strong></p>

<ul>
<li>R0: Address of format string</li>
<li>R1, R2, R3: VALUES to print (not addresses!)</li>
</ul>

<p><strong>Example: Print Integer</strong></p>

<p><strong>C Code</strong></p>
<pre><code class="language-c">printf("Result: %d\n", result);</code></pre>

<p><strong>ARM Assembly</strong></p>
<pre><code class="language-asm6502">.data
formatP: .asciz "Result: %d\n"
.text
    LDR R1, [SP, #0]     ; R1 = result (value, not address)
    ADD SP, SP, #4       ; Release stack space
    LDR R0, =formatP
    BL printf</code></pre>


<h3>8.6.3 Data Section and Format Strings</h3>

<p><strong>Data Section</strong></p>
<pre><code class="language-asm6502">.data
formatS: .asciz "%d"           ; Input format
formatP: .asciz "Result: %d\n"  ; Output format
array: .word 1, 2, 3, 4         ; Array
message: .asciz "Hello"         ; String</code></pre>

<p><strong>.asciz Directive</strong></p>

<ul>
<li>Defines null-terminated string</li>
<li>Automatically adds '\\0' at end</li>
<li>Stored in data section (separate from code)</li>
</ul>

<p><strong>Pseudo-Operation: LDR Rd, =label</strong></p>

<pre><code class="language-asm6502">LDR R0, =formatS     ; Loads ADDRESS of formatS into R0</code></pre>

<ul>
<li>Not actual LDR instruction</li>
<li>Assembler converts to appropriate instruction(s)</li>
<li>Loads memory address (pointer), not content</li>
</ul>

<h3>8.6.4 scanf vs printf Argument Differences</h3>

<p><strong>scanf: Needs Addresses</strong></p>

<pre><code class="language-asm6502">SUB SP, SP, #4
MOV R1, SP           ; R1 = address (where to store)
BL scanf</code></pre>

<p><strong>printf: Needs Values</strong></p>

<pre><code class="language-asm6502">LDR R1, [SP]         ; R1 = value (what to print)
BL printf</code></pre>

<p><strong>Why This Difference?</strong></p>

<ul>
<li>scanf modifies variables (needs addresses to write to)</li>
<li>printf only reads values (copies values)</li>
</ul>

<h3>8.6.5 Calling Convention Rules</h3>

<p><strong>Follow Exact Order</strong></p>

<ul>
<li>R0 first, R1 second, R2 third, R3 fourth</li>
<li>Library functions expect specific argument positions</li>
<li>Assembly won't check violations</li>
<li>Mistakes cause wrong behavior or crashes</li>
</ul>

<p><strong>Know Function Signatures</strong></p>

<ul>
<li>Read documentation</li>
<li>Understand parameter types and order</li>
<li>Match assembly to C function prototype</li>
</ul>

<h2>8.7 Compilation, Linking, and Loading</h2>

<h3>8.7.1 Translation Overview</h3>

<p><strong>Complete Process</strong></p>

<pre><code>C Program (.c)
↓ [Compiler]
↓ [Assembler]
Object Module (.o)
↓ [Linker]
Executable (a.out)
↓ [Loader]
Memory (running program)</code></pre>


<h3>8.7.2 Compiler</h3>

<p><strong>Function</strong></p>

<ul>
<li>Converts high-level C code to assembly language</li>
<li>Complex task requiring sophisticated algorithms</li>
<li>Performs optimizations</li>
</ul>

<p><strong>Optimizations</strong></p>

<ul>
<li>Register allocation</li>
<li>Instruction selection</li>
<li>Loop unrolling</li>
<li>Dead code elimination</li>
<li>Function inlining</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-c">int add(int a, int b) {
    return a + b;
}</code></pre>

<p>↓ Compiler</p>
<pre><code class="language-asm6502">add:
    ADD R0, R0, R1
    MOV PC, LR</code></pre>


<h3>8.7.3 Assembler</h3>

<p><strong>Function</strong></p>

<ul>
<li>Converts assembly language to machine code (binary)</li>
<li>Simpler than compilation (mostly 1-to-1 mapping)</li>
<li>Produces object modules</li>
</ul>

<p><strong>Tasks</strong></p>

<ol>
<li>Translate instructions to binary opcodes</li>
<li>Resolve local labels to addresses</li>
<li>Generate symbol table</li>
<li>Create relocation information</li>
</ol>

<p><strong>Object Module Structure</strong></p>

<p><strong>Header</strong></p>

<ul>
<li>Describes contents and sizes</li>
</ul>

<p><strong>Text Segment</strong></p>

<ul>
<li>Machine instructions (binary code)</li>
</ul>

<p><strong>Static Data Segment</strong></p>

<ul>
<li>Initialized global variables</li>
<li>String constants (format strings)</li>
</ul>

<p><strong>Relocation Info</strong></p>

<ul>
<li>Instructions/data depending on absolute addresses</li>
<li>Needed when program loaded at different address</li>
</ul>

<p><strong>Symbol Table</strong></p>

<ul>
<li>Global definitions: functions, variables defined here</li>
<li>External references: functions/variables from other modules</li>
<li>Enables linking</li>
</ul>

<p><strong>Debug Info</strong></p>

<ul>
<li>Maps machine code to source code lines</li>
<li>Used by debuggers (gdb)</li>
</ul>

<h3>8.7.4 Linker</h3>

<p><strong>Function</strong></p>

<ul>
<li>Combines multiple object modules into executable</li>
<li>Links program code with library code</li>
</ul>

<p><strong>Tasks</strong></p>

<p><strong>1. Merge Segments</strong></p>
<pre><code>program.o:      lib.o:          Result:
[Text1]         [Text2]     →   [Text1+Text2]
[Data1]         [Data2]     →   [Data1+Data2]</code></pre>

<p><strong>2. Resolve Labels</strong></p>

<ul>
<li>Convert symbolic names to actual addresses</li>
<li>Example: "printf" → 0x80481234</li>
<li>Processor only understands addresses</li>
</ul>

<p><strong>3. Patch References</strong></p>

<ul>
<li>Update function calls to correct addresses</li>
<li>Fix relocatable addresses</li>
<li>May leave some for loader</li>
</ul>

<h3>8.7.5 Static vs Dynamic Linking</h3>

<p><strong>Static Linking</strong></p>

<ul>
<li>Library code copied into executable at compile time</li>
<li>Larger executable files</li>
<li>Self-contained (no external dependencies)</li>
<li>All code in one file</li>
</ul>

<p><strong>Advantages</strong></p>

<ul>
<li>No runtime dependencies</li>
<li>Faster load time</li>
<li>Predictable behavior</li>
</ul>

<p><strong>Disadvantages</strong></p>

<ul>
<li>Large file sizes</li>
<li>No benefit from library updates</li>
<li>Memory duplication across programs</li>
</ul>

<p><strong>Dynamic Linking</strong></p>

<ul>
<li>Library code loaded at runtime when called</li>
<li>Smaller executables</li>
<li>Shared libraries on system</li>
</ul>

<p><strong>Advantages</strong></p>

<ul>
<li>Smaller executables</li>
<li>Shared libraries (less memory usage)</li>
<li>Automatic library updates</li>
<li>Less disk space</li>
</ul>

<p><strong>Disadvantages</strong></p>

<ul>
<li>Requires libraries installed on system</li>
<li>"DLL not found" errors</li>
<li>Slightly slower initial load</li>
</ul>

<p><strong>DLL (Dynamic Link Library) - Windows</strong></p>

<ul>
<li>File extension: .dll</li>
<li>Shared by multiple programs</li>
<li>Must be present on system</li>
<li>Example: msvcrt.dll (C runtime library)</li>
</ul>

<h3>8.7.6 Loader</h3>

<p><strong>Function</strong></p>

<ul>
<li>Loads executable from disk into memory</li>
<li>Prepares program for execution</li>
<li>Initializes execution environment</li>
</ul>

<p><strong>Loading Steps</strong></p>

<p><strong>1. Read Header</strong></p>

<ul>
<li>Determine segment sizes</li>
<li>Text segment size</li>
<li>Data segment size</li>
<li>Other metadata</li>
</ul>

<p><strong>2. Create Virtual Address Space</strong></p>

<ul>
<li>Allocate memory for program</li>
<li>Set up page tables (virtual memory)</li>
<li>Map segments to physical memory</li>
</ul>

<p><strong>3. Copy Segments to Memory</strong></p>

<ul>
<li>Text segment (instructions)</li>
<li>Initialized data</li>
<li>Set up page table entries</li>
<li>Mark text as read-only, data as read-write</li>
</ul>

<p><strong>4. Set Up Arguments on Stack</strong></p>

<ul>
<li>Command-line arguments: argc, argv</li>
<li>Environment variables</li>
<li>Initial stack frame</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-bash">./program arg1 arg2</code></pre>

<ul>
<li>argc = 3</li>
<li>argv[0] = "./program"</li>
<li>argv[1] = "arg1"</li>
<li>argv[2] = "arg2"</li>
</ul>

<p><strong>5. Initialize Registers</strong></p>

<ul>
<li>Set up register file</li>
<li>PC points to entry point (\_start)</li>
<li>SP points to top of stack</li>
<li>Other registers to initial values</li>
</ul>

<p><strong>6. Jump to Startup Routine</strong></p>

<ul>
<li>Calls C runtime initialization</li>
<li>Sets up standard library</li>
<li>Calls main() function</li>
<li>When main returns, calls exit()</li>
</ul>

<h2>8.8 Exercises</h2>

<h3>8.8.1 Common String Operations</h3>

<p><strong>String Length</strong></p>

<pre><code class="language-c">int strlen(char *s) {
    int len = 0;
    while (s[len] != '\0')
        len++;
    return len;
}</code></pre>

<p><strong>String Reverse</strong></p>

<pre><code class="language-c">void strrev(char *s) {
    int len = strlen(s);
    for (int i = 0; i < len/2; i++) {
        char temp = s[i];
        s[i] = s[len-1-i];
        s[len-1-i] = temp;
    }
}</code></pre>


<h3>8.8.2 Integer I/O</h3>

<p><strong>Read Two Integers, Print Sum</strong></p>

<pre><code class="language-asm6502">; Read x and y
; Print x + y</code></pre>

<p><strong>Read n, Print 1 to n</strong></p>

<pre><code class="language-asm6502">; Read n
; Loop from 1 to n, print each</code></pre>

<h3>8.8.3 Skills Required</h3>

<ul>
<li>Character data handling (LDRB/STRB)</li>
<li>String manipulation</li>
<li>scanf for input</li>
<li>printf for output</li>
<li>Stack management</li>
<li>Function calling conventions</li>
<li>Loop implementation</li>
<li>Array indexing</li>
</ul>

<h2>Key Takeaways</h2>

<ol>
<li><strong>ASCII (7-bit), Latin-1 (8-bit), Unicode (32-bit)</strong> represent character data with increasing capacity.</li>

<li><strong>LDRB/STRB for byte operations</strong>, LDRH/STRH for half-words - smaller than word operations.</li>

<li><strong>Byte operations don't require alignment</strong> unlike word operations (LDR/STR).</li>

<li><strong>Sign extension (LDRSB/LDRSH)</strong> replicates sign bit to preserve signed values.</li>

<li><strong>Strings in C are char arrays</strong> terminated with null character ('\\0' = 0).</li>

<li><strong>scanf and printf are library functions</strong> called via BL instruction.</li>

<li><strong>scanf needs addresses (where to store)</strong>, printf needs values (what to print).</li>

<li><strong>Format strings stored in .data section</strong> using .asciz directive.</li>

<li><strong>Arguments passed in R0-R3</strong> following ARM calling convention.</li>

<li><strong>Compilation chain: Compile → Assemble → Link → Load → Execute</strong>.</li>

<li><strong>Static linking includes libraries in executable</strong>, dynamic linking loads at runtime.</li>

<li><strong>Loader sets up virtual memory, copies segments, initializes stack</strong> with arguments.</li>
</ol>

<h2>Summary</h2>

<p>Character data handling and library function usage bridge high-level programming concepts and assembly implementation. Understanding byte/half-word operations enables efficient string manipulation and compact data storage. The scanf/printf functions demonstrate how assembly code interfaces with system libraries, requiring careful attention to calling conventions and argument types. The compilation, linking, and loading process reveals how source code transforms into running programs, involving multiple stages with distinct responsibilities. Static and dynamic linking represent different trade-offs between self-containment and flexibility. These concepts are essential for systems programming, understanding program structure, and debugging low-level issues. This knowledge prepares us for advanced topics including operating systems, compilers, and system-level optimization.</p>

            
            <div class="lecture-nav">
                <a href="lecture-07.html" class="nav-btn">← Previous Lecture</a>
                <a href="lecture-09.html" class="nav-btn">Next Lecture →</a>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 CO224 Computer Architecture Lecture Series. All rights reserved.</p>
            <p>Department of Computer Engineering, University of Peradeniya</p>
        </div>
    </footer>
</body>
</html>
