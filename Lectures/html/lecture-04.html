<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture 4: Introduction to ARM Assembly - Lectures on Computer Architecture</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-c.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-asm6502.min.js"></script>
</head>
<body>
    <header class="lecture-header">
        <div class="container">
            <a href="../../index.html" class="back-link">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                Back to All Lectures
            </a>
            <h1 class="lecture-title">Lecture 4: Introduction to ARM Assembly</h1>
            <p class="lecture-meta">Lectures on Computer Architecture</p>
        </div>
    </header>

    <main class="lecture-content-area container">
        <div class="content-body">
            <!-- Video Section -->
            <div class="video-container">
                <div class="video-thumbnail">
                    <a href="https://www.youtube.com/watch?v=s1X7Rr7rzag" target="_blank" class="video-play-overlay">
                        <img src="https://img.youtube.com/vi/s1X7Rr7rzag/maxresdefault.jpg" 
                             alt="Lecture 4 Video Thumbnail"
                             onerror="this.src='https://img.youtube.com/vi/s1X7Rr7rzag/hqdefault.jpg'">
                        <div class="play-button">
                            <svg width="68" height="48" viewBox="0 0 68 48" fill="none">
                                <path d="M66.52 7.74c-.78-2.93-2.49-5.41-5.42-6.19C55.79.13 34 0 34 0S12.21.13 6.9 1.55c-2.93.78-4.63 3.26-5.42 6.19C.06 13.05 0 24 0 24s.06 10.95 1.48 16.26c.78 2.93 2.49 5.41 5.42 6.19C12.21 47.87 34 48 34 48s21.79-.13 27.1-1.55c2.93-.78 4.64-3.26 5.42-6.19C67.94 34.95 68 24 68 24s-.06-10.95-1.48-16.26z" fill="red"/>
                                <path d="M45 24L27 14v20" fill="white"/>
                            </svg>
                        </div>
                    </a>
                </div>
                <div class="video-info">
                    <p class="video-notice">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="16" x2="12" y2="12"></line>
                            <line x1="12" y1="8" x2="12.01" y2="8"></line>
                        </svg>
                        Click the thumbnail above to watch the video lecture on YouTube
                    </p>
                </div>
            </div>

            
<em>By Dr. Kisaru Liyanage</em>

<h2>4.1 Introduction</h2>

<p>This lecture introduces ARM assembly language programming, providing the foundation for understanding how high-level programs translate to machine code. We explore the ARM instruction set architecture (ISA), focusing on its RISC design philosophy, register organization, basic instruction formats, and the toolchain used for development. Understanding assembly language is essential for comprehending how processors execute programs and for optimizing performance-critical code.</p>


<h2>4.2 ARM Architecture Overview</h2>

<h3>4.2.1 RISC Philosophy</h3>

<p><strong>Reduced Instruction Set Computer (RISC)</strong></p>

<ul>
<li>Simple, uniform instruction format</li>
<li>Fixed instruction length (32 bits in ARM)</li>
<li>Load/store architecture (only LOAD/STORE access memory)</li>
<li>Large number of general-purpose registers</li>
<li>Few addressing modes</li>
<li>Hardware simplicity for higher clock rates</li>
</ul>

<p><strong>Contrasted with CISC (Complex Instruction Set Computer)</strong></p>

<table>
<thead>
<tr>
<th>Feature</th>
<th>RISC</th>
<th>CISC</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Instruction Format</strong></td>
<td>Simple, uniform format</td>
<td>Variable-length instructions</td>
</tr>
<tr>
<td><strong>Instruction Complexity</strong></td>
<td>Simple instructions, more instructions per program</td>
<td>Complex operations</td>
</tr>
<tr>
<td><strong>Memory Access</strong></td>
<td>Load/store architecture (only LOAD/STORE access memory)</td>
<td>Memory operands in arithmetic operations</td>
</tr>
<tr>
<td><strong>Registers</strong></td>
<td>Large number of general-purpose registers</td>
<td>Fewer registers</td>
</tr>
<tr>
<td><strong>Hardware Design</strong></td>
<td>Hardware simplicity for higher clock rates</td>
<td>More complex hardware</td>
</tr>
<tr>
<td><strong>Pipelining</strong></td>
<td>Regular structure enables efficient pipelining</td>
<td>More difficult to pipeline</td>
</tr>
</tbody>
</table>


<p><strong>ARM Design Principles</strong></p>

<ul>
<li>Simplicity enables high performance</li>
<li>Regular instruction encoding aids decoding</li>
<li>Load/store architecture simplifies memory access</li>
<li>Large register file reduces memory traffic</li>
<li>Consistent design across instruction types</li>
</ul>

<h3>4.2.2 ARM Registers</h3>

<p><strong>General-Purpose Registers</strong></p>

<ul>
<li><strong>R0 to R15</strong>: 16 registers total</li>
<li><strong>32 bits wide</strong>: Can hold integers, addresses, or data</li>
<li><strong>R0-R12</strong>: General computation and data storage</li>
<li><strong>R13 (SP)</strong>: Stack Pointer - points to top of stack</li>
<li><strong>R14 (LR)</strong>: Link Register - stores return address</li>
<li><strong>R15 (PC)</strong>: Program Counter - address of next instruction</li>
</ul>

<p><strong>Register Usage Conventions</strong></p>

<div align="center">
<img src="../img/Chapter%202%20ARM%20Conventions.jpg" alt="ARM Register Usage Conventions" width="600">
<p><em>Figure 1: ARM Register Usage Conventions</em></p>
</div>

<pre><code class="language-asm6502">R0-R3:   Argument/result registers
- Pass parameters to functions
- Return values from functions
- Scratch registers (not preserved)

R4-R11:  Local variable registers
- Must be preserved across function calls
- Callee saves/restores if used

R12:     Intra-procedure-call scratch register
- Can be corrupted by function calls
- Not preserved

R13 (SP): Stack Pointer
- Points to top of stack
- Must always be valid

R14 (LR): Link Register
- Stores return address on function call
- Contains address to return to

R15 (PC): Program Counter
- Always points to next instruction
- Modifying PC changes execution flow
</code></pre>

<p><strong>Why So Many Registers?</strong></p>

<ul>
<li>Reduces memory accesses (faster than cache/RAM)</li>
<li>Enables register allocation by compiler</li>
<li>Supports efficient function calls</li>
<li>Improves performance through locality</li>
</ul>

<h3>4.2.3 Memory Organization</h3>

<p><strong>Little-Endian Byte Ordering</strong></p>

<ul>
<li>Least significant byte at lowest address</li>
<li>Example: 0x12345678 stored as:</li>
</ul>

<pre><code>Address:  [base+0] [base+1] [base+2] [base+3]
Content:     78       56       34       12
</code></pre>


<p><strong>Word Alignment</strong></p>

<ul>
<li>Words are 32 bits (4 bytes)</li>
<li>Word addresses should be multiples of 4</li>
<li>Accessing unaligned words may cause errors or slowdown</li>
</ul>

<p><strong>Address Space</strong></p>

<ul>
<li>32-bit addresses can access 2³² bytes = 4 GB</li>
<li>Byte-addressable memory</li>
<li>Instructions and data in same address space (Von Neumann architecture)</li>
</ul>

<h2>4.3 ARM Instruction Format</h2>

<h3>4.3.1 Instruction Structure</h3>

<p><strong>Fixed 32-Bit Length</strong></p>

<ul>
<li>Every instruction exactly 32 bits</li>
<li>Simplifies instruction fetch and decode</li>
<li>Enables predictable pipeline operation</li>
</ul>

<p><strong>Typical Instruction Fields</strong></p>

<pre><code>[Condition][Opcode][Operands]
4 bits    varies   varies
</code></pre>

<p><strong>Example: ADD Instruction</strong></p>

<pre><code class="language-asm6502">ADD R1, R2, R3    ; R1 = R2 + R3
</code></pre>

<p>Encoding includes:</p>
<ul>
<li>Condition code (usually "always")</li>
<li>Opcode for ADD operation</li>
<li>Destination register (R1)</li>
<li>Source register 1 (R2)</li>
<li>Source register 2 (R3)</li>
</ul>


<h3>4.3.2 Instruction Types</h3>

<p><strong>Data Processing Instructions</strong></p>

<ul>
<li>Arithmetic: ADD, SUB, RSB (reverse subtract)</li>
<li>Logical: AND, ORR, EOR (XOR), BIC (bit clear)</li>
<li>Comparison: CMP, CMN, TST, TEQ</li>
<li>Move: MOV, MVN (move negated)</li>
<li>Shift/Rotate: LSL, LSR, ASR, ROR</li>
</ul>

<p><strong>Data Transfer Instructions</strong></p>

<ul>
<li>Load: LDR (word), LDRB (byte), LDRH (halfword)</li>
<li>Store: STR (word), STRB (byte), STRH (halfword)</li>
<li>Multiple: LDM, STM (load/store multiple registers)</li>
</ul>

<p><strong>Control Flow Instructions</strong></p>

<ul>
<li>Branch: B (unconditional), BEQ, BNE, BGE, BLT, etc.</li>
<li>Function call: BL (branch and link)</li>
<li>Return: MOV PC, LR</li>
</ul>

<h3>4.3.3 Operand Types</h3>

<p><strong>Register Operands</strong></p>

<pre><code class="language-asm6502">ADD R0, R1, R2    ; R0 = R1 + R2 (all registers)
</code></pre>

<p><strong>Immediate Operands</strong></p>

<pre><code class="language-asm6502">ADD R0, R1, #5    ; R0 = R1 + 5 (# indicates immediate)
MOV R2, #100      ; R2 = 100
</code></pre>


<p><strong>Immediate Value Constraints</strong></p>

<ul>
<li>Limited to certain patterns due to 32-bit instruction encoding</li>
<li>8-bit immediate + 4-bit rotation</li>
<li>Assembler warns if immediate cannot be encoded</li>
</ul>

<p><strong>Shifted Register Operands</strong></p>

<pre><code class="language-asm6502">ADD R0, R1, R2, LSL #2    ; R0 = R1 + (R2 << 2)
SUB R3, R4, R5, LSR #1    ; R3 = R4 - (R5 >> 1)
</code></pre>


<h2>4.4 Basic ARM Instructions</h2>

<h3>4.4.1 Arithmetic Instructions</h3>

<p><strong>Addition</strong></p>

<pre><code class="language-asm6502">ADD Rd, Rn, Rm       ; Rd = Rn + Rm
ADD Rd, Rn, #imm     ; Rd = Rn + immediate
</code></pre>

<p>Examples:</p>

<pre><code class="language-asm6502">ADD R0, R1, R2       ; R0 = R1 + R2
ADD R3, R3, #1       ; R3 = R3 + 1 (increment)
</code></pre>


<p><strong>Subtraction</strong></p>

<pre><code class="language-asm6502">SUB Rd, Rn, Rm       ; Rd = Rn - Rm
SUB Rd, Rn, #imm     ; Rd = Rn - immediate
RSB Rd, Rn, #imm     ; Rd = immediate - Rn (reverse subtract)
</code></pre>

<p>Examples:</p>

<pre><code class="language-asm6502">SUB R0, R1, R2       ; R0 = R1 - R2
SUB R4, R4, #10      ; R4 = R4 - 10 (decrement)
RSB R5, R6, #0       ; R5 = 0 - R6 (negate)
</code></pre>

<p><strong>Multiplication</strong> (covered in later tutorials)</p>

<pre><code class="language-asm6502">MUL Rd, Rn, Rm       ; Rd = Rn × Rm (lower 32 bits)
</code></pre>


<h3>4.4.2 Logical Instructions</h3>

<p><strong>AND Operation</strong></p>

<pre><code class="language-asm6502">AND Rd, Rn, Rm       ; Rd = Rn AND Rm
AND Rd, Rn, #imm     ; Rd = Rn AND immediate
</code></pre>

<p>Usage: Bit masking, clearing specific bits</p>

<p>Example:</p>

<pre><code class="language-asm6502">AND R0, R0, #0xFF    ; Keep only lower 8 bits
</code></pre>

<p><strong>OR Operation</strong></p>

<pre><code class="language-asm6502">ORR Rd, Rn, Rm       ; Rd = Rn OR Rm (ORR in ARM)
ORR Rd, Rn, #imm     ; Rd = Rn OR immediate
</code></pre>

<p>Usage: Setting specific bits</p>

<p>Example:</p>

<pre><code class="language-asm6502">ORR R1, R1, #0x80    ; Set bit 7
</code></pre>

<p><strong>Exclusive OR</strong></p>

<pre><code class="language-asm6502">EOR Rd, Rn, Rm       ; Rd = Rn XOR Rm
EOR Rd, Rn, #imm     ; Rd = Rn XOR immediate
</code></pre>

<p>Usage: Toggling bits, fast comparison</p>

<p>Example:</p>

<pre><code class="language-asm6502">EOR R2, R2, R2       ; R2 = 0 (XOR with itself)
</code></pre>

<p><strong>Move and Move Not</strong></p>

<pre><code class="language-asm6502">MOV Rd, Rm           ; Rd = Rm
MOV Rd, #imm         ; Rd = immediate
MVN Rd, Rm           ; Rd = NOT Rm (bitwise complement)
</code></pre>

<p>Examples:</p>

<pre><code class="language-asm6502">MOV R0, R1           ; Copy R1 to R0
MOV R2, #0           ; Clear R2
MVN R3, R4           ; R3 = ~R4 (invert all bits)
</code></pre>


<h3>4.4.3 Shift Operations</h3>

<p><strong>Logical Shift Left (LSL)</strong></p>

<pre><code class="language-asm6502">LSL Rd, Rn, #shift   ; Rd = Rn << shift
MOV Rd, Rn, LSL #shift
</code></pre>

<p>Effect: Multiplies by 2^shift</p>

<p>Example:</p>

<pre><code class="language-asm6502">LSL R0, R1, #2       ; R0 = R1 × 4
</code></pre>

<p><strong>Logical Shift Right (LSR)</strong></p>

<pre><code class="language-asm6502">LSR Rd, Rn, #shift   ; Rd = Rn >> shift (unsigned)
MOV Rd, Rn, LSR #shift
</code></pre>

<p>Effect: Divides by 2^shift (unsigned)</p>

<p>Example:</p>

<pre><code class="language-asm6502">LSR R0, R1, #3       ; R0 = R1 / 8
</code></pre>

<p><strong>Arithmetic Shift Right (ASR)</strong></p>

<pre><code class="language-asm6502">ASR Rd, Rn, #shift   ; Rd = Rn >> shift (signed)
</code></pre>

<p>Effect: Divides by 2^shift, preserves sign</p>

<p>Example:</p>

<pre><code class="language-asm6502">ASR R0, R1, #2       ; R0 = R1 / 4 (signed)
</code></pre>

<p><strong>Rotate Right (ROR)</strong></p>

<pre><code class="language-asm6502">ROR Rd, Rn, #shift   ; Rotate Rn right by shift
</code></pre>

<p>Effect: Bits rotated off right end reappear at left</p>

<p>Example:</p>

<pre><code class="language-asm6502">ROR R0, R1, #8       ; Rotate R1 right by 8 bits
</code></pre>


<h2>4.5 Memory Access Instructions</h2>

<h3>4.5.1 Load Instructions</h3>

<p><strong>Load Word (LDR)</strong></p>

<pre><code class="language-asm6502">LDR Rd, [Rn]         ; Rd = Memory[Rn]
LDR Rd, [Rn, #offset]; Rd = Memory[Rn + offset]
</code></pre>

<p>Examples:</p>

<pre><code class="language-asm6502">LDR R0, [R1]         ; Load word from address in R1
LDR R2, [R3, #4]     ; Load from address R3+4
LDR R4, [R5, #-8]    ; Load from address R5-8
</code></pre>

<p><strong>Load Byte (LDRB)</strong></p>

<pre><code class="language-asm6502">LDRB Rd, [Rn, #offset]; Load one byte, zero-extend to 32 bits
</code></pre>

<p>Example:</p>

<pre><code class="language-asm6502">LDRB R0, [R1]        ; R0 = (byte at R1), upper 24 bits = 0
</code></pre>

<p><strong>Load Halfword (LDRH)</strong></p>

<pre><code class="language-asm6502">LDRH Rd, [Rn, #offset]; Load 16 bits, zero-extend to 32 bits
</code></pre>

<p>Example:</p>

<pre><code class="language-asm6502">LDRH R0, [R1, #2]    ; R0 = (halfword at R1+2), upper 16 bits = 0
</code></pre>

<p><strong>Pseudo-Instruction for Loading Addresses</strong></p>

<pre><code class="language-asm6502">LDR Rd, =label       ; Load address of label into Rd
LDR Rd, =value       ; Load 32-bit constant into Rd
</code></pre>

<p>Examples:</p>

<pre><code class="language-asm6502">LDR R0, =array       ; R0 = address of array
LDR R1, =0x12345678  ; R1 = 0x12345678 (large immediate)
</code></pre>


<h3>4.5.2 Store Instructions</h3>

<p><strong>Store Word (STR)</strong></p>

<pre><code class="language-asm6502">STR Rd, [Rn]         ; Memory[Rn] = Rd
STR Rd, [Rn, #offset]; Memory[Rn + offset] = Rd
</code></pre>

<p>Examples:</p>

<pre><code class="language-asm6502">STR R0, [R1]         ; Store R0 to address in R1
STR R2, [R3, #8]     ; Store R2 to address R3+8
</code></pre>

<p><strong>Store Byte (STRB)</strong></p>

<pre><code class="language-asm6502">STRB Rd, [Rn, #offset]; Store lower 8 bits of Rd
</code></pre>

<p>Example:</p>

<pre><code class="language-asm6502">STRB R0, [R1]        ; Store lower byte of R0 to address R1
</code></pre>

<p><strong>Store Halfword (STRH)</strong></p>

<pre><code class="language-asm6502">STRH Rd, [Rn, #offset]; Store lower 16 bits of Rd
</code></pre>

<p>Example:</p>

<pre><code class="language-asm6502">STRH R0, [R1, #4]    ; Store lower halfword of R0 to R1+4
</code></pre>


<h3>4.5.3 Addressing Modes</h3>

<p><strong>Offset Addressing</strong></p>

<pre><code class="language-asm6502">LDR R0, [R1, #4]     ; R0 = Memory[R1 + 4], R1 unchanged
</code></pre>

<p><strong>Pre-indexed Addressing</strong></p>

<pre><code class="language-asm6502">LDR R0, [R1, #4]!    ; R1 = R1 + 4, then R0 = Memory[R1]
; ! indicates update base register
</code></pre>

<p><strong>Post-indexed Addressing</strong></p>

<pre><code class="language-asm6502">LDR R0, [R1], #4     ; R0 = Memory[R1], then R1 = R1 + 4
</code></pre>

<p><strong>Register Offset</strong></p>

<pre><code class="language-asm6502">LDR R0, [R1, R2]     ; R0 = Memory[R1 + R2]
LDR R0, [R1, R2, LSL #2] ; R0 = Memory[R1 + (R2 << 2)]
</code></pre>


<h2>4.6 Assembly Program Structure</h2>

<h3>4.6.1 Directives</h3>

<p><strong>Section Directives</strong></p>

<pre><code class="language-asm6502">.text                ; Code section (instructions)
.data                ; Data section (initialized variables)
.bss                 ; Uninitialized data section
</code></pre>

<p><strong>Global and External</strong></p>

<pre><code class="language-asm6502">.global main         ; Make symbol visible to linker
.extern printf       ; Declare external symbol
</code></pre>

<p><strong>Data Definition</strong></p>

<pre><code class="language-asm6502">.word value          ; Define 32-bit word
.byte value          ; Define byte
.asciz "string"      ; Define null-terminated string
.space n             ; Reserve n bytes of space
</code></pre>


<h3>4.6.2 Labels</h3>

<p><strong>Purpose</strong></p>

<ul>
<li>Mark locations in code or data</li>
<li>Provide symbolic names for addresses</li>
<li>Enable jumps and references</li>
</ul>

<p><strong>Syntax</strong></p>

<pre><code class="language-asm6502">label:               ; Label for instruction
    MOV R0, #1
    ADD R1, R0, R2

array:               ; Label for data
    .word 1, 2, 3, 4
</code></pre>


<h3>4.6.3 Simple Program Example</h3>

<pre><code class="language-asm6502">.text
.global main

main:
    MOV R0, #5       ; R0 = 5
    MOV R1, #10      ; R1 = 10
    ADD R2, R0, R1   ; R2 = R0 + R1 = 15
    MOV R0, R2       ; R0 = R2 (return value)
    MOV PC, LR       ; Return from main

.data
message:
    .asciz "Hello, ARM!"
</code></pre>


<h2>4.7 ARM Development Tools</h2>

<h3>4.7.1 Toolchain Components</h3>

<p><strong>Cross-Compiler</strong></p>

<ul>
<li><code>arm-linux-gnueabi-gcc</code>: Compiles C to ARM code</li>
<li>Runs on x86 PC, produces ARM binaries</li>
<li>Necessary because development machine ≠ target machine</li>
</ul>

<p><strong>Assembler</strong></p>

<ul>
<li><code>arm-linux-gnueabi-as</code>: Assembles ARM assembly to object code</li>
<li>Part of binutils package</li>
</ul>

<p><strong>Linker</strong></p>

<ul>
<li><code>arm-linux-gnueabi-ld</code>: Links object files to executable</li>
<li>Resolves symbols, combines code sections</li>
</ul>

<p><strong>Emulator</strong></p>

<ul>
<li><code>qemu-arm</code>: Emulates ARM processor on x86</li>
<li>Allows running ARM binaries on PC</li>
<li>Useful for testing without ARM hardware</li>
</ul>

<h3>4.7.2 Compilation Process</h3>

<p><strong>From C to Executable</strong></p>

<pre><code>C Source (.c)
    ↓ [gcc -S]
Assembly (.s)
    ↓ [as]
Object Code (.o)
    ↓ [ld]
Executable (a.out)
    ↓ [qemu-arm]
Execution
</code></pre>

<p><strong>Command Examples</strong></p>

<pre><code class="language-bash"># Compile C to assembly
arm-linux-gnueabi-gcc -S program.c -o program.s

# Assemble to object code
arm-linux-gnueabi-as program.s -o program.o

# Link to executable
arm-linux-gnueabi-gcc program.o -o program

# Run with emulator
qemu-arm program
</code></pre>

<p><strong>One-Step Compilation</strong></p>

<pre><code class="language-bash"># Compile, assemble, and link in one command
arm-linux-gnueabi-gcc program.c -o program
</code></pre>


<h3>4.7.3 Debugging and Inspection</h3>

<p><strong>GDB (GNU Debugger)</strong></p>

<pre><code class="language-bash"># Debug with QEMU and GDB
qemu-arm -g 1234 program &     # Start QEMU, wait for debugger
arm-linux-gnueabi-gdb program  # Start GDB
(gdb) target remote :1234      # Connect to QEMU
(gdb) break main               # Set breakpoint
(gdb) continue                 # Run to breakpoint
(gdb) step                     # Execute one instruction
(gdb) info registers           # Show register values
</code></pre>

<p><strong>Objdump</strong></p>

<pre><code class="language-bash"># Disassemble binary to assembly
arm-linux-gnueabi-objdump -d program
</code></pre>

<p><strong>nm</strong></p>

<pre><code class="language-bash"># List symbols in object file
arm-linux-gnueabi-nm program.o
</code></pre>


<h2>4.8 Programming in ARM Assembly</h2>

<h3>4.8.1 Translating C to ARM</h3>

<p><strong>C Code:</strong></p>

<pre><code class="language-c">int a = 5;
int b = 10;
int c = a + b;
</code></pre>

<p><strong>ARM Assembly:</strong></p>

<pre><code class="language-asm6502">MOV R0, #5       ; a = 5
MOV R1, #10      ; b = 10
ADD R2, R0, R1   ; c = a + b
</code></pre>

<p><strong>C Code with Array:</strong></p>

<pre><code class="language-c">int arr[3] = {1, 2, 3};
int x = arr[1];
</code></pre>

<p><strong>ARM Assembly:</strong></p>

<pre><code class="language-asm6502">.data
arr:
    .word 1, 2, 3

.text
    LDR R0, =arr     ; R0 = address of arr
    LDR R1, [R0, #4] ; R1 = arr[1] (offset 4 bytes)
</code></pre>


<h3>4.8.2 Common Patterns</h3>

<p><strong>Clearing a Register</strong></p>

<pre><code class="language-asm6502">MOV R0, #0           ; Method 1
EOR R0, R0, R0       ; Method 2 (XOR with itself)
</code></pre>

<p><strong>Negating a Value</strong></p>

<pre><code class="language-asm6502">RSB R0, R0, #0       ; R0 = 0 - R0
MVN R0, R0           ; R0 = ~R0 (bitwise, not arithmetic)
ADD R0, R0, #1       ; Then add 1 (two's complement)
</code></pre>

<p><strong>Multiplying by Powers of 2</strong></p>

<pre><code class="language-asm6502">LSL R0, R1, #3       ; R0 = R1 × 8 (faster than MUL)
</code></pre>

<p><strong>Dividing by Powers of 2</strong></p>

<pre><code class="language-asm6502">LSR R0, R1, #2       ; R0 = R1 / 4 (unsigned)
ASR R0, R1, #2       ; R0 = R1 / 4 (signed)
</code></pre>

<p><strong>Swapping Two Registers</strong></p>

<pre><code class="language-asm6502">EOR R0, R0, R1       ; XOR-based swap (no temporary)
EOR R1, R0, R1
EOR R0, R0, R1
</code></pre>


<h2>Key Takeaways</h2>

<ol>
<li><strong>ARM follows RISC principles</strong> - simple instructions, load/store architecture, large register file, fixed instruction length.</li>

<li><strong>16 registers (R0-R15)</strong> with special purposes: R13 (SP), R14 (LR), R15 (PC), and calling conventions for R0-R11.</li>

<li><strong>Three main instruction categories</strong> - data processing (arithmetic/logic), data transfer (load/store), control flow (branches).</li>

<li><strong>Fixed 32-bit instruction format</strong> simplifies hardware and enables efficient pipelining.</li>

<li><strong>Little-endian byte ordering</strong> - least significant byte stored at lowest address.</li>

<li><strong>Immediate values</strong> indicated by # symbol, with encoding constraints due to fixed instruction size.</li>

<li><strong>Memory access only through LOAD/STORE</strong> - arithmetic operations work on registers only (load/store architecture).</li>

<li><strong>Rich addressing modes</strong> - offset, pre-indexed, post-indexed, register offset with optional shifts.</li>

<li><strong>Cross-compilation toolchain</strong> - arm-linux-gnueabi-gcc, as, ld, and qemu-arm for development on x86.</li>

<li><strong>Assembly programming requires understanding</strong> of register allocation, instruction selection, and calling conventions.</li>
</ol>

<h2>Summary</h2>

<p>ARM assembly language provides the low-level interface between software and hardware, revealing how high-level constructs translate to machine operations. The ARM architecture's RISC design emphasizes simplicity and regularity, with a uniform 32-bit instruction format, a generous 16-register set, and a clean separation between computation (using registers) and memory access (through explicit load/store instructions). Understanding ARM assembly is crucial for optimizing performance-critical code, implementing system-level software, and comprehending how processors execute programs. The development toolchain—including cross-compilers, assemblers, linkers, and emulators—enables efficient development and testing of ARM software. Mastering these fundamentals prepares us for more advanced topics including function calling conventions, stack management, and processor microarchitecture implementation.</p>

            
            <div class="lecture-nav">
                <a href="lecture-03.html" class="nav-btn">← Previous Lecture</a>
                <a href="lecture-05.html" class="nav-btn">Next Lecture →</a>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 CO224 Computer Architecture Lecture Series. All rights reserved.</p>
            <p>Department of Computer Engineering, University of Peradeniya</p>
        </div>
    </footer>
</body>
</html>
