<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture 6: Branching - Lectures on Computer Architecture</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
            onload="renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ]
            });"></script>
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-asm6502.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
</head>
<body>
    <header class="lecture-header">
        <div class="container">
            <a href="../../index.html" class="back-link">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                Back to All Lectures
            </a>
            <h1 class="lecture-title">Lecture 6: Branching</h1>
            <p class="lecture-meta">Lectures on Computer Architecture</p>
        </div>
    </header>

    <main class="lecture-content-area container">
        <div class="content-body">
            <!-- Video Section -->
            <div class="video-container">
                <div class="video-thumbnail">
                    <a href="https://www.youtube.com/watch?v=aFCmb1CNnV8" target="_blank" class="video-play-overlay">
                        <img src="https://img.youtube.com/vi/aFCmb1CNnV8/maxresdefault.jpg" 
                             alt="Lecture 6 Video Thumbnail"
                             onerror="this.src='https://img.youtube.com/vi/aFCmb1CNnV8/hqdefault.jpg'">
                        <div class="play-button">
                            <svg width="68" height="48" viewBox="0 0 68 48" fill="none">
                                <path d="M66.52 7.74c-.78-2.93-2.49-5.41-5.42-6.19C55.79.13 34 0 34 0S12.21.13 6.9 1.55c-2.93.78-4.63 3.26-5.42 6.19C.06 13.05 0 24 0 24s.06 10.95 1.48 16.26c.78 2.93 2.49 5.41 5.42 6.19C12.21 47.87 34 48 34 48s21.79-.13 27.1-1.55c2.93-.78 4.64-3.26 5.42-6.19C67.94 34.95 68 24 68 24s-.06-10.95-1.48-16.26z" fill="red"/>
                                <path d="M45 24L27 14v20" fill="white"/>
                            </svg>
                        </div>
                    </a>
                </div>
                <div class="video-info">
                    <p class="video-notice">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="16" x2="12" y2="12"></line>
                            <line x1="12" y1="8" x2="12.01" y2="8"></line>
                        </svg>
                        Click the thumbnail above to watch the video lecture on YouTube
                    </p>
                </div>
            </div>

            
<em>By Dr. Kisaru Liyanage</em>

<h2>6.1 Introduction</h2>

<p>Control flow is what distinguishes computers from simple calculators—the ability to make decisions and alter execution based on conditions. This lecture explores conditional operations and branching in ARM assembly, covering comparison instructions, conditional branches, loop implementation, and PC-relative addressing. Understanding these mechanisms is essential for translating high-level control structures (if statements, loops) into assembly code and for comprehending how processors implement dynamic program behavior.</p>


<h2>6.2 Fundamentals of Conditional Execution</h2>

<h3>6.2.1 Decision-Making in Computers</h3>

<p><strong>What Makes Computers Powerful</strong></p>

<ul>
<li>Ability to make decisions based on data</li>
<li>Execute different instructions depending on conditions</li>
<li>Implement if statements, loops, and function calls</li>
<li>Respond dynamically to input and computed values</li>
</ul>

<p><strong>Control Flow Concepts</strong></p>

<ul>
<li><strong>Sequential execution</strong>: Default behavior (PC += 4)</li>
<li><strong>Conditional branching</strong>: Jump if condition is true</li>
<li><strong>Unconditional branching</strong>: Always jump</li>
<li><strong>Function calls</strong>: Branch with return address saving</li>
</ul>

<h3>6.2.2 Program Status Register (PSR)</h3>

<p><strong>Status Flags</strong></p>

<ul>
<li><strong>N (Negative)</strong>: Set if result is negative (bit 31 = 1)</li>
<li><strong>Z (Zero)</strong>: Set if result is zero</li>
<li><strong>C (Carry)</strong>: Set if unsigned overflow occurred</li>
<li><strong>V (oVerflow)</strong>: Set if signed overflow occurred</li>
</ul>

<p><strong>How Flags Are Set</strong></p>

<ul>
<li>Comparison instructions (CMP, CMN, TST, TEQ)</li>
<li>Arithmetic/logic instructions with S suffix (ADDS, SUBS)</li>
<li>Flags reflect the result of the operation</li>
<li>Used by subsequent conditional branches</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">CMP R1, R2           ; Compare R1 and R2 (computes R1 - R2)
; Sets flags based on result
</code></pre>

<p>If R1 = 5, R2 = 3:</p>

<ul>
<li>Result of R1 - R2 = 2 (positive, non-zero)</li>
<li>N = 0 (not negative)</li>
<li>Z = 0 (not zero)</li>
<li>C = 1 (no borrow needed)</li>
<li>V = 0 (no overflow)</li>
</ul>

<h2>6.3 Comparison Instructions</h2>

<h3>6.3.1 Compare (CMP)</h3>

<p><strong>Syntax</strong></p>

<pre><code class="language-asm6502">CMP Rn, Rm           ; Compare Rn with Rm
CMP Rn, #imm         ; Compare Rn with immediate
</code></pre>

<p><strong>Operation</strong></p>

<ul>
<li>Performs Rn - Rm (subtraction)</li>
<li>Updates PSR flags based on result</li>
<li>Does NOT store the result</li>
<li>Does NOT modify any register</li>
</ul>

<p><strong>Example Usage</strong></p>

<pre><code class="language-asm6502">MOV R1, #10
MOV R2, #5
CMP R1, R2           ; Compares 10 with 5
; Result: 10 - 5 = 5 (positive, non-zero)
; Z = 0, N = 0
</code></pre>

<h3>6.3.2 Compare Negative (CMN)</h3>

<p><strong>Syntax</strong></p>

<pre><code class="language-asm6502">CMN Rn, Rm           ; Compare Negative
CMN Rn, #imm
</code></pre>

<p><strong>Operation</strong></p>

<ul>
<li>Performs Rn + Rm (addition)</li>
<li>Updates PSR flags</li>
<li>Equivalent to CMP Rn, -Rm</li>
<li>Useful for checking if sum equals zero</li>
</ul>

<h3>6.3.3 Test (TST)</h3>

<p><strong>Syntax</strong></p>

<pre><code class="language-asm6502">TST Rn, Rm           ; Test bits
TST Rn, #imm
</code></pre>

<p><strong>Operation</strong></p>

<ul>
<li>Performs Rn AND Rm (bitwise AND)</li>
<li>Updates PSR flags</li>
<li>Result not stored</li>
<li>Used to test if specific bits are set</li>
</ul>

<p><strong>Example: Check if bit 5 is set</strong></p>

<pre><code class="language-asm6502">TST R1, #0x20        ; Test bit 5
BEQ bit_clear        ; Branch if bit was clear (Z=1)
</code></pre>

<h3>6.3.4 Test Equivalence (TEQ)</h3>

<p><strong>Syntax</strong></p>

<pre><code class="language-asm6502">TEQ Rn, Rm           ; Test Equivalence
TEQ Rn, #imm
</code></pre>

<p><strong>Operation</strong></p>

<ul>
<li>Performs Rn XOR Rm (exclusive OR)</li>
<li>Updates PSR flags</li>
<li>Z=1 if values are equal</li>
<li>Used to compare values without affecting C or V flags</li>
</ul>

<h2>6.4 Conditional Branch Instructions</h2>

<h3>6.4.1 Branch if Equal (BEQ)</h3>

<p><strong>Syntax</strong></p>

<pre><code class="language-asm6502">BEQ label            ; Branch if equal (Z=1)
</code></pre>

<p><strong>Condition</strong></p>

<ul>
<li>Branches if Zero flag is set (Z = 1)</li>
<li>Typically used after CMP to check equality</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">CMP R1, R2           ; Compare R1 and R2
BEQ equal_label      ; Jump to equal_label if R1 == R2
; Code if not equal
equal_label:
; Code if equal
</code></pre>

<h3>6.4.2 Branch if Not Equal (BNE)</h3>

<p><strong>Syntax</strong></p>

<pre><code class="language-asm6502">BNE label            ; Branch if not equal (Z=0)
</code></pre>

<p><strong>Condition</strong></p>

<ul>
<li>Branches if Zero flag is clear (Z = 0)</li>
<li>Opposite of BEQ</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">CMP R3, #0
BNE not_zero         ; Jump if R3 != 0
; Code if R3 is zero
not_zero:
; Code if R3 is non-zero
</code></pre>

<h3>6.4.3 Signed Comparison Branches</h3>

<p><strong>Branch if Greater or Equal (BGE)</strong></p>

<pre><code class="language-asm6502">BGE label            ; Branch if Rn >= Rm (signed)
; Condition: N == V
</code></pre>

<p><strong>Branch if Less Than (BLT)</strong></p>

<pre><code class="language-asm6502">BLT label            ; Branch if Rn < Rm (signed)
; Condition: N != V
</code></pre>

<p><strong>Branch if Greater Than (BGT)</strong></p>

<pre><code class="language-asm6502">BGT label            ; Branch if Rn > Rm (signed)
; Condition: Z==0 AND N==V
</code></pre>

<p><strong>Branch if Less or Equal (BLE)</strong></p>

<pre><code class="language-asm6502">BLE label            ; Branch if Rn <= Rm (signed)
; Condition: Z==1 OR N!=V
</code></pre>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">CMP R1, R2
BGE greater_equal    ; Branch if R1 >= R2 (signed)
; Code if R1 < R2
greater_equal:
; Code if R1 >= R2
</code></pre>

<h3>6.4.4 Unsigned Comparison Branches</h3>

<p><strong>Branch if Higher or Same (BHS)</strong> (also called BCS - Branch if Carry Set)</p>

<pre><code class="language-asm6502">BHS label            ; Branch if Rn >= Rm (unsigned)
; Condition: C == 1
</code></pre>

<p><strong>Branch if Lower (BLO)</strong> (also called BCC - Branch if Carry Clear)</p>

<pre><code class="language-asm6502">BLO label            ; Branch if Rn < Rm (unsigned)
; Condition: C == 0
</code></pre>

<p><strong>Branch if Higher (BHI)</strong></p>

<pre><code class="language-asm6502">BHI label            ; Branch if Rn > Rm (unsigned)
; Condition: C==1 AND Z==0
</code></pre>

<p><strong>Branch if Lower or Same (BLS)</strong></p>

<pre><code class="language-asm6502">BLS label            ; Branch if Rn <= Rm (unsigned)
; Condition: C==0 OR Z==1
</code></pre>

<h3>6.4.5 Signed vs. Unsigned Example</h3>

<p><strong>Key Difference</strong></p>

<pre><code class="language-asm6502">MOV R0, #0xFFFFFFFF  ; R0 = -1 (signed) or 4,294,967,295 (unsigned)
MOV R1, #1           ; R1 = 1
CMP R0, R1

BLO lower_unsigned   ; BRANCH NOT TAKEN
; Unsigned: 4,294,967,295 > 1

BLT less_signed      ; BRANCH TAKEN
; Signed: -1 < 1
</code></pre>

<p><strong>When to Use Each</strong></p>

<ul>
<li><strong>Signed</strong>: Comparing integers that can be negative (temperatures, offsets, differences)</li>
<li><strong>Unsigned</strong>: Comparing addresses, array indices, sizes, counts</li>
</ul>

<h3>6.4.6 Unconditional Branch</h3>

<p><strong>Syntax</strong></p>

<pre><code class="language-asm6502">B label              ; Branch always
</code></pre>

<p><strong>Purpose</strong></p>

<ul>
<li>Jump without checking any condition</li>
<li>Skip code sections</li>
<li>Implement infinite loops</li>
<li>Return to loop start</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">B end                ; Skip this section
; Code to skip
end:
; Continue execution here
</code></pre>

<h2>6.5 Labels in Assembly</h2>

<h3>6.5.1 Label Definition</h3>

<p><strong>Purpose</strong></p>

<ul>
<li>Mark specific instruction locations</li>
<li>Provide symbolic names for addresses</li>
<li>Enable branches and data references</li>
</ul>

<p><strong>Syntax</strong></p>

<pre><code class="language-asm6502">label:               ; Label definition (note colon)
MOV R0, #1           ; Instruction at this label
</code></pre>

<p><strong>Naming Rules</strong></p>

<ul>
<li>Can be almost any identifier</li>
<li>Common conventions: loop, exit, done, L1, L2</li>
<li>Cannot conflict with instruction mnemonics</li>
<li>Case-sensitive</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">start:
MOV R0, #0
loop:
ADD R0, R0, #1
CMP R0, #10
BLT loop         ; Branch to loop label
B start          ; Branch to start label
</code></pre>

<h3>6.5.2 Label Resolution</h3>

<p><strong>Assembly Process</strong></p>

<ol>
<li>First pass: Record label addresses</li>
<li>Second pass: Replace labels with addresses</li>
<li>Calculate offsets for PC-relative branches</li>
</ol>

<p><strong>Virtual Addresses</strong></p>

<ul>
<li>Assembler assigns virtual addresses from 0</li>
<li>First instruction: address 0</li>
<li>Second instruction: address 4</li>
<li>Third instruction: address 8</li>
<li>Physical addresses determined at load time</li>
</ul>

<h2>6.6 Implementing Control Structures</h2>

<h3>6.6.1 If Statement</h3>

<p><strong>C Code</strong></p>

<pre><code class="language-c">if (i == j)
    f = g + h;
else
    f = g - h;
</code></pre>

<p><strong>ARM Assembly (Method 1: Branch on False)</strong></p>

<pre><code class="language-asm6502">CMP R3, R4       ; Compare i (R3) and j (R4)
BNE else         ; Branch to else if not equal
ADD R0, R1, R2   ; f = g + h (then clause)
B exit           ; Skip else clause

else:
SUB R0, R1, R2   ; f = g - h (else clause)
exit:
; Continue...
</code></pre>

<p><strong>ARM Assembly (Method 2: Conditional Execution)</strong></p>

<pre><code class="language-asm6502">CMP R3, R4       ; Compare i and j
ADDEQ R0, R1, R2 ; f = g + h (executed only if equal)
SUBNE R0, R1, R2 ; f = g - h (executed only if not equal)
</code></pre>


<h3>6.6.2 If-Else Ladder</h3>

<p><strong>C Code</strong></p>

<pre><code class="language-c">if (x < 0)
    result = -1;
else if (x == 0)
    result = 0;
else
    result = 1;
</code></pre>

<p><strong>ARM Assembly</strong></p>

<pre><code class="language-asm6502">CMP R1, #0       ; Compare x with 0
BLT negative     ; Branch if x < 0
BEQ zero         ; Branch if x == 0
; x > 0
MOV R0, #1
B done

negative:
MOV R0, #-1
B done
zero:
MOV R0, #0
done:
; Continue...
</code></pre>

<h3>6.6.3 While Loop</h3>

<p><strong>C Code</strong></p>

<pre><code class="language-c">while (i < n) {
    sum += i;
    i++;
}
</code></pre>

<p><strong>ARM Assembly</strong></p>

<pre><code class="language-asm6502">loop:
CMP R1, R2       ; Compare i (R1) with n (R2)
BGE end_loop     ; Exit if i >= n
ADD R0, R0, R1   ; sum = sum + i
ADD R1, R1, #1   ; i++
B loop           ; Branch back to loop start
end_loop:
; Continue...
</code></pre>

<h3>6.6.4 For Loop</h3>

<p><strong>C Code</strong></p>

<pre><code class="language-c">for (i = 0; i < 10; i++) {
    sum += i;
}
</code></pre>

<p><strong>ARM Assembly</strong></p>

<pre><code class="language-asm6502">MOV R1, #0       ; i = 0 (initialization)

for_loop:
CMP R1, #10      ; Compare i with 10
BGE end_for      ; Exit if i >= 10
ADD R0, R0, R1   ; sum = sum + i (loop body)
ADD R1, R1, #1   ; i++ (increment)
B for_loop       ; Branch back to loop start
end_for:
; Continue...
</code></pre>

<h3>6.6.5 Do-While Loop</h3>

<p><strong>C Code</strong></p>

<pre><code class="language-c">do {
    sum += i;
    i++;
} while (i < n);
</code></pre>

<p><strong>ARM Assembly</strong></p>

<pre><code class="language-asm6502">do_loop:
ADD R0, R0, R1   ; sum = sum + i (loop body first)
ADD R1, R1, #1   ; i++
CMP R1, R2       ; Compare i with n
BLT do_loop      ; Branch back if i < n
; Continue...
</code></pre>

<p><strong>Key Difference from While</strong></p>

<ul>
<li>Body executes at least once</li>
<li>Condition checked at end, not beginning</li>
</ul>

<h2>6.7 Array Access in Loops</h2>

<h3>6.7.1 Static Array Indexing</h3>

<p><strong>C Code</strong></p>

<pre><code class="language-c">while (save[i] == k)
    i++;
</code></pre>

<p><strong>ARM Assembly</strong></p>

<pre><code class="language-asm6502">; R6 = base address of save array
; R3 = i (index)
; R5 = k (comparison value)

loop:
ADD R12, R6, R3, LSL #2  ; address = base + (i * 4)
LDR R0, [R12, #0]        ; R0 = save[i]
CMP R0, R5               ; Compare save[i] with k
BNE exit                 ; Exit if not equal
ADD R3, R3, #1           ; i++
B loop                   ; Continue loop
exit:
; Continue...
</code></pre>

<p><strong>Dynamic Offset Calculation</strong></p>

<ul>
<li><code>R3, LSL #2</code> means <code>R3 × 4</code> (shift left by 2 = multiply by 4)</li>
<li>Words are 4 bytes, so array element <code>i</code> is at <code>base + (i * 4)</code></li>
<li>Shifting is typically faster than an explicit multiply (uses the barrel shifter)</li>
</ul>

<h3>6.7.2 Array Traversal</h3>

<p><strong>C Code</strong></p>

<pre><code class="language-c">int sum = 0;
for (int i = 0; i < 10; i++) {
    sum += arr[i];
}
</code></pre>

<p><strong>ARM Assembly</strong></p>

<pre><code class="language-asm6502">LDR R6, =arr     ; R6 = base address of array
MOV R0, #0       ; sum = 0
MOV R1, #0       ; i = 0

loop:
CMP R1, #10
BGE done
ADD R12, R6, R1, LSL #2  ; address = base + i*4
LDR R2, [R12]            ; R2 = arr[i]
ADD R0, R0, R2           ; sum += arr[i]
ADD R1, R1, #1           ; i++
B loop
done:
; R0 contains sum
</code></pre>

<h2>6.8 PC-Relative Addressing</h2>

<h3>6.8.1 Branch Instruction Encoding</h3>

<p><strong>32-Bit Format</strong></p>


<p>[Cond][1010][Offset]</p>
<p>4-bit 4-bit 24-bit</p>


<p><strong>Fields</strong></p>

<ul>
<li><strong>Cond</strong>: Condition code (EQ, NE, LT, etc.)</li>
<li><strong>1010</strong>: Fixed format field for branch</li>
<li><strong>Offset</strong>: 24-bit signed offset</li>
</ul>

<h3>6.8.2 Address Calculation</h3>

<p><strong>Problem with Absolute Addressing</strong></p>

<ul>
<li>24 bits can address 2²⁴ = 16 MB</li>
<li>Limits program size to 16 MB</li>
<li>Fixed addresses complicate relocation</li>
</ul>

<p><strong>PC-Relative Solution</strong></p>

<ul>
<li>Store offset from current PC, not absolute address</li>
<li>Target = PC + offset</li>
<li>Can branch ±16 MB from current instruction</li>
<li>Total program can exceed 16 MB</li>
</ul>

<p><strong>Offset Calculation</strong></p>


<p>Offset = (Target Address - PC) / 4</p>


<p><strong>Why Divide by 4?</strong></p>

<ul>
<li>All instructions are 4-byte aligned</li>
<li>Least significant 2 bits always 00</li>
<li>Omit these bits in encoding</li>
<li>Effective range: ±64 MB (24-bit offset × 4)</li>
</ul>

<p><strong>Example</strong></p>


<p>Current PC: 0x1000</p>
<p>Target: 0x1020</p>
<p>Offset = (0x1020 - 0x1000) / 4 = 0x20 / 4 = 8 instructions</p>

<p>Encoded offset in branch instruction: 8</p>
<p>At execution: PC = 0x1000 + (8 × 4) = 0x1020</p>


<h3>6.8.3 Advantages of PC-Relative</h3>

<p><strong>Position-Independent Code</strong></p>

<ul>
<li>Code can load at any address</li>
<li>Branches remain correct regardless of location</li>
<li>Essential for libraries and shared code</li>
</ul>

<p><strong>Simplified Linking</strong></p>

<ul>
<li>Linker doesn't need to patch all branches</li>
<li>Only external function calls need adjustment</li>
</ul>

<p><strong>Branch Locality</strong></p>

<ul>
<li>Most branches are to nearby instructions</li>
<li>PC-relative naturally handles this case</li>
<li>Absolute addressing wastes bits for nearby targets</li>
</ul>

<h2>6.9 Conditional Execution (Alternative to Branching)</h2>

<h3>6.9.1 Conditional Instruction Suffixes</h3>

<p><strong>Concept</strong></p>

<ul>
<li>Add condition code to instruction mnemonic</li>
<li>Instruction executes only if condition is true</li>
<li>Otherwise, instruction is skipped (NOP)</li>
</ul>

<p><strong>Available Suffixes</strong></p>

<ul>
<li>EQ (equal), NE (not equal)</li>
<li>GT, LT, GE, LE (signed comparisons)</li>
<li>HI, LO, HS, LS (unsigned comparisons)</li>
<li>Many others (see ARM documentation)</li>
</ul>

<p><strong>Examples</strong></p>

<pre><code class="language-asm6502">CMP R1, R2
ADDEQ R0, R3, R4     ; Execute ADD only if R1 == R2
SUBNE R0, R3, R4     ; Execute SUB only if R1 != R2
MOVGT R5, #10        ; Execute MOV only if R1 > R2
</code></pre>

<h3>6.9.2 Conditional Execution Example</h3>

<p><strong>C Code</strong></p>

<pre><code class="language-c">if (a == b)
    max = a;
else
    max = b;
</code></pre>

<p><strong>Method 1: Branching</strong></p>

<pre><code class="language-asm6502">CMP R1, R2       ; Compare a and b
BNE else
MOV R0, R1       ; max = a
B done

else:
MOV R0, R2       ; max = b
done:
</code></pre>

<p><strong>Method 2: Conditional Execution</strong></p>

<pre><code class="language-asm6502">CMP R1, R2       ; Compare a and b
MOVEQ R0, R1     ; max = a (if equal)
MOVNE R0, R2     ; max = b (if not equal)
</code></pre>


<h3>6.9.3 Advantages and Limitations</h3>

<p><strong>Advantages</strong></p>

<ul>
<li>More compact code (fewer instructions)</li>
<li>No branch misprediction penalty</li>
<li>Faster for simple conditions</li>
<li>Clearer intent in some cases</li>
</ul>

<p><strong>Limitations</strong></p>

<ul>
<li>Only works for simple, short sequences</li>
<li>Cannot conditionally execute blocks of code</li>
<li>All conditional instructions must fit in pipeline</li>
<li>May execute both paths (but discard one result)</li>
</ul>

<p><strong>When to Use</strong></p>

<ul>
<li>Simple assignments</li>
<li>Min/max operations</li>
<li>Short computations with single result</li>
<li>Performance-critical paths where branches hurt</li>
</ul>

<h2>6.10 Basic Blocks</h2>

<h3>6.10.1 Definition</h3>

<p><strong>Basic Block Characteristics</strong></p>

<ul>
<li>Sequence of instructions with:
<ul>
<li>No embedded branches (except possibly at end)</li>
<li>No branch targets (except possibly at beginning)</li>
</ul>
</li>
<li>Executed atomically: all or nothing</li>
<li>Single entry point, single exit point</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">; Basic Block 1 (entry point)
MOV R0, #0
MOV R1, #10
CMP R1, #10
BNE block2       ; Exit point of block 1

; Basic Block 2 (entry and exit point)
block2:
ADD R0, R0, #1
CMP R0, R1
BLT block2       ; Exit point of block 2
</code></pre>

<h3>6.10.2 Importance in Compilation</h3>

<p><strong>Compiler Optimizations</strong></p>

<ul>
<li>Identify basic blocks for analysis</li>
<li>Optimize within blocks (register allocation, scheduling)</li>
<li>Build control flow graph from blocks</li>
<li>Apply inter-block optimizations</li>
</ul>

<p><strong>Processor Optimizations</strong></p>

<ul>
<li>Predict block execution</li>
<li>Prefetch instructions in block</li>
<li>Schedule instructions more aggressively</li>
<li>Reduce branch overhead</li>
</ul>

<h2>Key Takeaways</h2>

<ol>
<li><strong>Conditional execution</strong> distinguishes computers from calculators, enabling decision-making and dynamic behavior.</li>

<li><strong>CMP instruction</strong> sets PSR flags by performing subtraction without storing the result.</li>

<li><strong>Conditional branches</strong> (BEQ, BNE, BGE, BLT, etc.) check PSR flags to decide whether to jump.</li>

<li><strong>Signed vs. unsigned branches</strong> interpret the same bit patterns differently based on context.</li>

<li><strong>Labels</strong> provide symbolic names for addresses, enabling readable branch targets.</li>

<li><strong>If statements</strong> translate to compare + conditional branch + unconditional branch to skip alternate path.</li>

<li><strong>Loops</strong> use compare + conditional branch (to exit) + unconditional branch (to continue).</li>

<li><strong>Array access</strong> in loops uses dynamic offset calculation with shifts (LSL #2 for word arrays).</li>

<li><strong>PC-relative addressing</strong> stores branch offset from current PC, enabling position-independent code and large programs.</li>

<li><strong>Word-based offsets</strong> effectively quadruple branch range by encoding instruction count instead of byte offset.</li>

<li><strong>Conditional execution</strong> provides alternative to branching for simple cases, improving performance and code density.</li>

<li><strong>Basic blocks</strong> are atomic instruction sequences used by compilers and processors for optimization.</li>

<li><strong>Branch locality</strong> means most branches target nearby instructions, making PC-relative addressing natural and efficient.</li>
</ol>

<h2>Summary</h2>

<p>Branching and conditional execution form the foundation of program control flow, translating high-level constructs like if statements and loops into machine instructions. The ARM architecture provides a rich set of conditional branches for both signed and unsigned comparisons, enabling efficient implementation of diverse control structures. Understanding the distinction between comparison (which sets flags) and branching (which checks flags) is essential for correct assembly programming. PC-relative addressing solves program size limitations while enabling position-independent code, and conditional execution offers a performant alternative to branching for simple cases. Mastering these concepts is crucial for translating algorithms into assembly code, optimizing performance-critical sections, and understanding how processors implement dynamic program behavior. These fundamentals prepare us for more advanced topics including function calls, stack management, and processor pipelining.</p>

            
            <div class="lecture-nav">
                <a href="lecture-05.html" class="nav-btn">← Previous Lecture</a>
                <a href="lecture-07.html" class="nav-btn">Next Lecture →</a>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 CO224 Computer Architecture Lecture Series. All rights reserved.</p>
            <p>Department of Computer Engineering, University of Peradeniya</p>
        </div>
    </footer>
</body>
</html>
