<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture 5: Number Representation and Data Processing - Lectures on Computer Architecture</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="lecture-header">
        <div class="container">
            <a href="../../index.html" class="back-link">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                Back to All Lectures
            </a>
            <h1 class="lecture-title">Lecture 5: Number Representation and Data Processing</h1>
            <p class="lecture-meta">Lectures on Computer Architecture</p>
        </div>
    </header>

    <main class="lecture-content-area container">
        <div class="content-body">
            <!-- Video Section -->
            <div class="video-container">
                <div class="video-thumbnail">
                    <a href="#video-lecture-05" target="_blank" class="video-play-overlay">
                        <img src="https://img.youtube.com/vi/VIDEO_ID_05/maxresdefault.jpg" 
                             alt="Lecture 5 Video Thumbnail"
                             onerror="this.src='https://img.youtube.com/vi/VIDEO_ID_05/hqdefault.jpg'">
                        <div class="play-button">
                            <svg width="68" height="48" viewBox="0 0 68 48" fill="none">
                                <path d="M66.52 7.74c-.78-2.93-2.49-5.41-5.42-6.19C55.79.13 34 0 34 0S12.21.13 6.9 1.55c-2.93.78-4.63 3.26-5.42 6.19C.06 13.05 0 24 0 24s.06 10.95 1.48 16.26c.78 2.93 2.49 5.41 5.42 6.19C12.21 47.87 34 48 34 48s21.79-.13 27.1-1.55c2.93-.78 4.64-3.26 5.42-6.19C67.94 34.95 68 24 68 24s-.06-10.95-1.48-16.26z" fill="red"/>
                                <path d="M45 24L27 14v20" fill="white"/>
                            </svg>
                        </div>
                    </a>
                </div>
                <div class="video-info">
                    <p class="video-notice">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="16" x2="12" y2="12"></line>
                            <line x1="12" y1="8" x2="12.01" y2="8"></line>
                        </svg>
                        Click the thumbnail above to watch the video lecture on YouTube
                    </p>
                </div>
            </div>

            <h1>Lecture 5: Number Representation and Data Processing</h1>

<h2>Introduction</h2>

<p>This lecture delves into how computers represent and manipulate data at the binary level. We explore number systems, two's complement representation for signed integers, instruction encoding formats in ARM assembly, and logical operations for bit manipulation. Understanding these fundamentals is essential for programming efficiently in assembly language and comprehending how processors execute arithmetic and logical operations.</p>

<p>---</p>

<h2>1. Number Representation Systems</h2>

<h3>1.1 Unsigned Binary Integers</h3>

<strong>Binary System Basics</strong>

<ul>
<li>Base-2 number system using digits 0 and 1</li>
<li>Each bit position represents a power of 2</li>
<li>Rightmost bit is least significant (LSB)</li>
<li>Leftmost bit is most significant (MSB)</li>
</ul>

<strong>Place Value Calculation</strong>

``<code>
<p>Binary: 1011</p>
<p>Value = (1 × 2³) + (0 × 2²) + (1 × 2¹) + (1 × 2⁰)</p>
<p>= 8 + 0 + 2 + 1</p>
<p>= 11 (decimal)</p>
</code>`<code>

<strong>N-Bit Unsigned Range</strong>

<ul>
<li>N bits can represent 2^N different values</li>
<li>Range: 0 to (2^N - 1)</li>
<li>8 bits: 0 to 255</li>
<li>32 bits: 0 to 4,294,967,295</li>
</ul>

<strong>Binary to Decimal Conversion</strong>

</code>`<code>
<p>Example: 10110101</p>
<p>= 1×128 + 0×64 + 1×32 + 1×16 + 0×8 + 1×4 + 0×2 + 1×1</p>
<p>= 128 + 32 + 16 + 4 + 1</p>
<p>= 181</p>
</code>`<code>

<h3>1.2 Two's Complement Representation</h3>

<strong>Purpose of Two's Complement</strong>

<ul>
<li>Represents both positive and negative integers</li>
<li>Simplifies hardware (same adder for signed/unsigned)</li>
<li>Unique zero representation</li>
<li>Natural overflow behavior</li>
</ul>

<strong>Sign Bit</strong>

<ul>
<li>MSB indicates sign</li>
<li>MSB = 0: Positive number</li>
<li>MSB = 1: Negative number</li>
</ul>

<strong>Positive Numbers</strong>

<ul>
<li>Same as unsigned binary</li>
<li>MSB is always 0</li>
<li>Example: +5 in 8 bits = 00000101</li>
</ul>

<strong>Negative Numbers</strong>

<ul>
<li>Represented as 2^N - |value|</li>
<li>Example: -5 in 8 bits:</li>
</ul>
</code>`<code>
<p>2^8 - 5 = 256 - 5 = 251 = 11111011</p>
</code>`<code>

<strong>Two's Complement Conversion</strong>
<p>Method 1 (Invert and Add):</p>

<p>1. Write positive value in binary</p>
<p>2. Invert all bits (0→1, 1→0)</p>
<p>3. Add 1 to result</p>

<p>Example: -5 in 8 bits</p>

</code>`<code>
<p>+5:        00000101</p>
<p>Invert:    11111010</p>
<p>Add 1:     11111011  (this is -5)</p>
</code>`<code>

<p>Method 2 (Subtraction):</p>

</code>`<code>
<p>-5 = 2^8 - 5 = 256 - 5 = 251 = 11111011</p>
</code>`<code>

<strong>N-Bit Signed Range</strong>

<ul>
<li>Range: -(2^(N-1)) to +(2^(N-1) - 1)</li>
<li>8 bits: -128 to +127</li>
<li>32 bits: -2,147,483,648 to +2,147,483,647</li>
</ul>

<strong>Special Cases</strong>

<ul>
<li>Zero: 00000000 (unique representation)</li>
<li>Most negative: 10000000 (-128 in 8 bits)</li>
</ul>
<p>- Has no positive counterpart!</p>
<p>- Negating gives overflow</p>

<h3>1.3 Sign Extension</h3>

<strong>Purpose</strong>

<ul>
<li>Extend smaller signed value to larger width</li>
<li>Preserve numerical value</li>
<li>Required when loading bytes/halfwords into 32-bit registers</li>
</ul>

<strong>Process</strong>

<ul>
<li>Replicate the sign bit (MSB) to fill new bits</li>
<li>Preserves positive/negative value</li>
</ul>

<strong>Examples</strong>

</code>`<code>
<p>8-bit to 32-bit:</p>
<p>00000101 (+5) → 00000000 00000000 00000000 00000101 (+5)</p>
<p>11111011 (-5) → 11111111 11111111 11111111 11111011 (-5)</p>
</code>`<code>

<strong>ARM Instructions for Sign Extension</strong>

<ul>
<li><strong>LDRH</strong>: Load halfword (16 bits), zero-extend to 32 bits</li>
<li><strong>LDRSH</strong>: Load signed halfword, sign-extend to 32 bits</li>
<li><strong>LDRB</strong>: Load byte (8 bits), zero-extend to 32 bits</li>
<li><strong>LDRSB</strong>: Load signed byte, sign-extend to 32 bits</li>
</ul>

<strong>Example Usage</strong>

</code>`<code>assembly
<p>LDRH R0, [R1]     ; R0 = 0x0000ABCD (zero-extended)</p>
<p>LDRSH R0, [R1]    ; R0 = 0xFFFFABCD (sign-extended if bit 15 = 1)</p>

<p>LDRB R0, [R1]     ; R0 = 0x000000AB (zero-extended)</p>
<p>LDRSB R0, [R1]    ; R0 = 0xFFFFFFAB (sign-extended if bit 7 = 1)</p>
</code>`<code>

<h3>1.4 Hexadecimal Notation</h3>

<strong>Why Hexadecimal?</strong>

<ul>
<li>Compact representation of binary</li>
<li>One hex digit = 4 binary bits</li>
<li>Easier to read than long binary strings</li>
<li>Common in programming and debugging</li>
</ul>

<strong>Hex Digits</strong>

</code>`<code>
<p>Binary  | Hex | Decimal</p>
<p>--------|-----|--------</p>
<p>0000    |  0  |   0</p>
<p>0001    |  1  |   1</p>
<p>0010    |  2  |   2</p>
<p>0011    |  3  |   3</p>
<p>0100    |  4  |   4</p>
<p>0101    |  5  |   5</p>
<p>0110    |  6  |   6</p>
<p>0111    |  7  |   7</p>
<p>1000    |  8  |   8</p>
<p>1001    |  9  |   9</p>
<p>1010    |  A  |  10</p>
<p>1011    |  B  |  11</p>
<p>1100    |  C  |  12</p>
<p>1101    |  D  |  13</p>
<p>1110    |  E  |  14</p>
<p>1111    |  F  |  15</p>
</code>`<code>

<strong>Conversion Examples</strong>

</code>`<code>
<p>Binary: 1011 0110 1101 0010</p>
<p>Hex:      B    6    D    2</p>
<p>Result: 0xB6D2</p>

<p>Hex: 0x3F</p>
<p>Binary: 0011 1111</p>
<p>Decimal: 63</p>
</code>`<code>

<strong>ARM Hexadecimal Usage</strong>

</code>`<code>assembly
<p>MOV R0, #0xFF        ; R0 = 255</p>
<p>MOV R1, #0x100       ; R1 = 256</p>
<p>LDR R2, =0xDEADBEEF  ; R2 = 3735928559</p>
</code>`<code>

<h2>2. ARM Instruction Encoding</h2>

<h3>2.1 Fixed-Length Instructions</h3>

<strong>32-Bit Instruction Format</strong>

<ul>
<li>Every ARM instruction is exactly 32 bits</li>
<li>Simplifies instruction fetch and decode</li>
<li>Enables efficient pipelining</li>
</ul>

<strong>Advantages</strong>

<ul>
<li>Predictable instruction boundaries</li>
<li>Simple PC increment (always +4)</li>
<li>Fast decode logic</li>
</ul>

<strong>Trade-offs</strong>

<ul>
<li>Some instructions may "waste" bits</li>
<li>Immediate values limited in size</li>
<li>Code density lower than variable-length (e.g., x86)</li>
</ul>

<h3>2.2 Data Processing Instruction Format</h3>

<strong>Format Structure</strong>

</code>`<code>
<p>[Cond][00][I][Opcode][S][Rn][Rd][Operand2]</p>
<p>4-bit 2  1   4-bit   1  4   4   12-bit</p>
</code>`<code>

<strong>Field Descriptions</strong>

<strong>Condition (4 bits, bits 28-31)</strong>

<ul>
<li>Conditional execution feature</li>
<li>0000 = EQ (equal, Z=1)</li>
<li>0001 = NE (not equal, Z=0)</li>
<li>1010 = GE (greater or equal, signed)</li>
<li>1110 = AL (always execute, default)</li>
</ul>

<strong>I bit (bit 25)</strong>

<ul>
<li>0 = Operand2 is register</li>
<li>1 = Operand2 is immediate value</li>
</ul>

<strong>Opcode (4 bits, bits 21-24)</strong>

<ul>
<li>Specifies operation (AND, EOR, SUB, ADD, etc.)</li>
<li>0100 = ADD</li>
<li>0010 = SUB</li>
<li>0000 = AND</li>
<li>1100 = ORR</li>
</ul>

<strong>S bit (bit 20)</strong>

<ul>
<li>0 = Don't update condition flags</li>
<li>1 = Update flags (CPSR)</li>
</ul>

<strong>Rn (4 bits, bits 16-19)</strong>

<ul>
<li>First operand register number</li>
<li>0000 = R0, 0001 = R1, etc.</li>
</ul>

<strong>Rd (4 bits, bits 12-15)</strong>

<ul>
<li>Destination register number</li>
</ul>

<strong>Operand2 (12 bits, bits 0-11)</strong>

<ul>
<li>If I=0: Shift amount and second register</li>
<li>If I=1: 8-bit immediate + 4-bit rotation</li>
</ul>

<strong>Example: ADD R0, R1, R2</strong>

</code>`<code>
<p>Encoding fields:</p>
<ul>
<li>Cond: 1110 (always)</li>
<li>I: 0 (register operand)</li>
<li>Opcode: 0100 (ADD)</li>
<li>S: 0 (don't update flags)</li>
<li>Rn: 0001 (R1)</li>
<li>Rd: 0000 (R0)</li>
<li>Operand2: 0002 (R2, no shift)</li>
</ul>

<p>Result: 0xE0810002</p>
</code>`<code>

<h3>2.3 Data Transfer Instruction Format</h3>

<strong>Format Structure</strong>

</code>`<code>
<p>[Cond][01][I][P][U][B][W][L][Rn][Rd][Offset]</p>
<p>4-bit 2  1  1  1  1  1  1  4   4   12-bit</p>
</code>`<code>

<strong>Key Fields</strong>

<strong>L bit (bit 20)</strong>

<ul>
<li>0 = Store (STR)</li>
<li>1 = Load (LDR)</li>
</ul>

<strong>B bit (bit 22)</strong>

<ul>
<li>0 = Word transfer (32 bits)</li>
<li>1 = Byte transfer (8 bits)</li>
</ul>

<strong>P bit (bit 24)</strong>

<ul>
<li>0 = Post-indexed addressing</li>
<li>1 = Pre-indexed or offset addressing</li>
</ul>

<strong>U bit (bit 23)</strong>

<ul>
<li>0 = Subtract offset from base</li>
<li>1 = Add offset to base</li>
</ul>

<strong>W bit (bit 21)</strong>

<ul>
<li>0 = No write-back</li>
<li>1 = Write-back (update base register)</li>
</ul>

<strong>Rn (base register)</strong>

<ul>
<li>Contains memory address or base address</li>
</ul>

<strong>Rd (data register)</strong>

<ul>
<li>For Load: Destination register</li>
<li>For Store: Source register</li>
</ul>

<strong>Offset (12 bits)</strong>

<ul>
<li>Memory address offset</li>
<li>Can be immediate or register</li>
</ul>

<strong>Example: LDR R0, [R1, #4]</strong>

</code>`<code>
<p>Encoding fields:</p>
<ul>
<li>Cond: 1110 (always)</li>
<li>L: 1 (load)</li>
<li>B: 0 (word)</li>
<li>P: 1 (offset addressing)</li>
<li>U: 1 (add offset)</li>
<li>Rn: 0001 (R1)</li>
<li>Rd: 0000 (R0)</li>
<li>Offset: 004 (immediate 4)</li>
</ul>

<p>Result: 0xE5910004</p>
</code>`<code>

<h3>2.4 Immediate Value Encoding</h3>

<strong>Challenge</strong>

<ul>
<li>32-bit instruction must fit: opcode, registers, immediate</li>
<li>Cannot fit full 32-bit immediate</li>
</ul>

<strong>ARM Solution: 8-bit + 4-bit Rotation</strong>

<ul>
<li>Immediate field: 12 bits total</li>
<li>Lower 8 bits: Immediate value (0-255)</li>
<li>Upper 4 bits: Rotation amount (0-15)</li>
<li>Rotation: Right by (2 × rotation field) bits</li>
</ul>

<strong>Calculation</strong>

</code>`<code>
<p>Actual Value = Immediate × ROR (2 × Rotation)</p>
</code>`<code>

<strong>Examples</strong>

</code>`<code>
<p>Immediate=0xFF, Rotation=0:</p>
<p>Value = 0xFF ROR 0 = 0x000000FF</p>

<p>Immediate=0xFF, Rotation=8:</p>
<p>Value = 0xFF ROR 16 = 0x00FF0000</p>

<p>Immediate=0xFF, Rotation=12:</p>
<p>Value = 0xFF ROR 24 = 0xFF000000</p>
</code>`<code>

<strong>Allowed Immediates</strong>

<ul>
<li>Not all 32-bit values can be encoded</li>
<li>Valid: 0xFF, 0xFF00, 0xFF0000, 0xFF000000</li>
<li>Valid: 0xFF000000FF (rotation wraps around)</li>
<li>Invalid: 0x123 (cannot be formed by rotation)</li>
</ul>

<strong>Assembler Handling</strong>

<ul>
<li>Assembler checks if immediate is valid</li>
<li>Gives error if immediate cannot be encoded</li>
<li>Use LDR pseudo-instruction for arbitrary values:</li>
</ul>
</code>`<code>assembly
<p>LDR R0, =0x12345678  ; Loads from literal pool</p>
</code>`<code>

<h2>3. Logical Operations</h2>

<h3>3.1 Bitwise AND</h3>

<strong>Operation</strong>

<ul>
<li>Performs logical AND on each bit pair</li>
<li>Result bit = 1 only if both input bits are 1</li>
</ul>

<strong>Truth Table</strong>

</code>`<code>
<p>A | B | A AND B</p>
<p>--|---|--------</p>
<p>0 | 0 |   0</p>
<p>0 | 1 |   0</p>
<p>1 | 0 |   0</p>
<p>1 | 1 |   1</p>
</code>`<code>

<strong>ARM Instruction</strong>

</code>`<code>assembly
<p>AND Rd, Rn, Rm       ; Rd = Rn AND Rm</p>
<p>AND Rd, Rn, #imm     ; Rd = Rn AND immediate</p>
</code>`<code>

<strong>Common Uses</strong>

<strong>Bit Masking (Extract Specific Bits)</strong>

</code>`<code>assembly
<p>; Extract lower 8 bits of R1</p>
<p>MOV R0, R1</p>
<p>AND R0, R0, #0xFF    ; R0 = R1 & 0xFF (keep bits 0-7)</p>

<p>; Extract bits 8-15</p>
<p>MOV R0, R1</p>
<p>AND R0, R0, #0xFF00  ; R0 = R1 & 0xFF00 (keep bits 8-15)</p>
</code>`<code>

<strong>Clearing Specific Bits</strong>

</code>`<code>assembly
<p>; Clear bit 5 of R1</p>
<p>AND R1, R1, #0xFFFFFFDF  ; Bit 5 mask: ~(1 << 5)</p>
</code>`<code>

<strong>Checking if Bit Set</strong>

</code>`<code>assembly
<p>AND R2, R1, #0x80    ; Check if bit 7 is set</p>
<p>CMP R2, #0           ; Compare with zero</p>
<p>BEQ bit_clear        ; Branch if bit was clear</p>
</code>`<code>

<h3>3.2 Bitwise OR</h3>

<strong>Operation</strong>

<ul>
<li>Performs logical OR on each bit pair</li>
<li>Result bit = 1 if either input bit is 1</li>
</ul>

<strong>Truth Table</strong>

</code>`<code>
<p>A | B | A OR B</p>
<p>--|---|-------</p>
<p>0 | 0 |   0</p>
<p>0 | 1 |   1</p>
<p>1 | 0 |   1</p>
<p>1 | 1 |   1</p>
</code>`<code>

<strong>ARM Instruction</strong>

</code>`<code>assembly
<p>ORR Rd, Rn, Rm       ; Rd = Rn OR Rm (ORR in ARM)</p>
<p>ORR Rd, Rn, #imm     ; Rd = Rn OR immediate</p>
</code>`<code>

<strong>Common Uses</strong>

<strong>Setting Specific Bits</strong>

</code>`<code>assembly
<p>; Set bit 3 of R1</p>
<p>ORR R1, R1, #0x08    ; Bit 3 mask: (1 << 3) = 0x08</p>

<p>; Set bits 4 and 5</p>
<p>ORR R1, R1, #0x30    ; Mask: 0x30 = 0b00110000</p>
</code>`<code>

<strong>Combining Values</strong>

</code>`<code>assembly
<p>; Combine lower byte of R1 with upper bytes of R2</p>
<p>AND R1, R1, #0xFF        ; Keep only lower byte</p>
<p>AND R2, R2, #0xFFFFFF00  ; Keep only upper bytes</p>
<p>ORR R0, R1, R2           ; Combine</p>
</code>`<code>

<h3>3.3 Bitwise XOR (Exclusive OR)</h3>

<strong>Operation</strong>

<ul>
<li>Performs logical XOR on each bit pair</li>
<li>Result bit = 1 if input bits differ</li>
</ul>

<strong>Truth Table</strong>

</code>`<code>
<p>A | B | A XOR B</p>
<p>--|---|--------</p>
<p>0 | 0 |   0</p>
<p>0 | 1 |   1</p>
<p>1 | 0 |   1</p>
<p>1 | 1 |   0</p>
</code>`<code>

<strong>ARM Instruction</strong>

</code>`<code>assembly
<p>EOR Rd, Rn, Rm       ; Rd = Rn EOR Rm (EOR in ARM)</p>
<p>EOR Rd, Rn, #imm     ; Rd = Rn EOR immediate</p>
</code>`<code>

<strong>Common Uses</strong>

<strong>Toggling Specific Bits</strong>

</code>`<code>assembly
<p>; Toggle bit 2 of R1</p>
<p>EOR R1, R1, #0x04    ; Bit 2 mask: (1 << 2)</p>
<p>; If bit was 0, becomes 1; if was 1, becomes 0</p>
</code>`<code>

<strong>Fast Zero</strong>

</code>`<code>assembly
<p>EOR R0, R0, R0       ; R0 = 0 (XOR with itself)</p>
</code>`<code>

<strong>Comparison</strong>

</code>`<code>assembly
<p>; Check if R1 and R2 are equal</p>
<p>EOR R3, R1, R2       ; R3 = R1 XOR R2</p>
<p>CMP R3, #0           ; If R3 = 0, R1 == R2</p>
<p>BEQ values_equal</p>
</code>`<code>

<strong>Swapping Without Temporary</strong>

</code>`<code>assembly
<p>; Swap R0 and R1 without using another register</p>
<p>EOR R0, R0, R1</p>
<p>EOR R1, R0, R1</p>
<p>EOR R0, R0, R1</p>
<p>; Now R0 and R1 are swapped</p>
</code>`<code>

<h3>3.4 Bitwise NOT</h3>

<strong>Operation</strong>

<ul>
<li>Inverts all bits (0→1, 1→0)</li>
<li>Also called complement</li>
</ul>

<strong>ARM Instruction</strong>

</code>`<code>assembly
<p>MVN Rd, Rm           ; Rd = NOT Rm (Move Not)</p>
<p>MVN Rd, #imm         ; Rd = NOT immediate</p>
</code>`<code>

<strong>Common Uses</strong>

<strong>Creating Bit Masks</strong>

</code>`<code>assembly
<p>; Create mask with all bits set except bit 3</p>
<p>MOV R0, #0x08        ; 0x08 = 0b00001000</p>
<p>MVN R1, R0           ; R1 = 0xFFFFFFF7 (all except bit 3)</p>
</code>`<code>

<strong>Negation (with ADD)</strong>

</code>`<code>assembly
<p>; Negate R1 (two's complement)</p>
<p>MVN R1, R1           ; Invert all bits</p>
<p>ADD R1, R1, #1       ; Add 1</p>
<p>; Now R1 = -R1 (original)</p>
</code>`<code>

<h3>3.5 Shift Operations</h3>

<strong>Logical Shift Left (LSL)</strong>

</code>`<code>assembly
<p>LSL Rd, Rn, #shift   ; Rd = Rn << shift</p>
<p>MOV Rd, Rn, LSL #shift</p>
</code>`<code>

<ul>
<li>Shifts bits left, fills right with zeros</li>
<li>Each shift left multiplies by 2</li>
<li>Example: 0b00001010 LSL 2 = 0b00101000</li>
</ul>

<strong>Logical Shift Right (LSR)</strong>

</code>`<code>assembly
<p>LSR Rd, Rn, #shift   ; Rd = Rn >> shift (unsigned)</p>
<p>MOV Rd, Rn, LSR #shift</p>
</code>`<code>

<ul>
<li>Shifts bits right, fills left with zeros</li>
<li>Each shift right divides by 2 (unsigned)</li>
<li>Example: 0b10100000 LSR 2 = 0b00101000</li>
</ul>

<strong>Arithmetic Shift Right (ASR)</strong>

</code>`<code>assembly
<p>ASR Rd, Rn, #shift   ; Rd = Rn >> shift (signed)</p>
</code>`<code>

<ul>
<li>Shifts bits right, fills left with sign bit</li>
<li>Preserves sign for signed division</li>
<li>Example: 0b11110000 ASR 2 = 0b11111100 (sign preserved)</li>
</ul>

<strong>Rotate Right (ROR)</strong>

</code>`<code>assembly
<p>ROR Rd, Rn, #shift   ; Rotate Rn right by shift</p>
</code>`<code>

<ul>
<li>Bits shifted out right reappear at left</li>
<li>No information lost</li>
<li>Example: 0b10000001 ROR 1 = 0b11000000</li>
</ul>

<strong>Common Shift Applications</strong>

<strong>Fast Multiplication/Division by Powers of 2</strong>

</code>`<code>assembly
<p>LSL R0, R1, #3       ; R0 = R1 × 8 (2^3)</p>
<p>LSR R0, R1, #2       ; R0 = R1 / 4 (unsigned)</p>
<p>ASR R0, R1, #2       ; R0 = R1 / 4 (signed)</p>
</code>`<code>

<strong>Bit Extraction</strong>

</code>`<code>assembly
<p>; Extract bits 8-11 from R1</p>
<p>LSR R0, R1, #8       ; Shift bits 8-11 to bits 0-3</p>
<p>AND R0, R0, #0xF     ; Mask to keep only 4 bits</p>
</code>`<code>

<strong>Bit Positioning</strong>

</code>`<code>assembly
<p>; Move bit 0 to bit 7</p>
<p>LSL R0, R1, #7       ; Shift left 7 positions</p>
<p>AND R0, R0, #0x80    ; Keep only bit 7</p>
</code>`<code>

<h2>4. Practical Bit Manipulation Examples</h2>

<h3>4.1 Extracting Bit Fields</h3>

<strong>Extract bits 16-23</strong>

</code>`<code>assembly
<p>LSR R0, R1, #16      ; Shift right to position</p>
<p>AND R0, R0, #0xFF    ; Mask to 8 bits</p>
</code>`<code>

<strong>Extract bits 4-9 (6 bits)</strong>

</code>`<code>assembly
<p>LSR R0, R1, #4       ; Shift to position 0</p>
<p>AND R0, R0, #0x3F    ; Mask to 6 bits (0b111111)</p>
</code>`<code>

<h3>4.2 Setting and Clearing Bits</h3>

<strong>Set bits 8-15</strong>

</code>`<code>assembly
<p>ORR R1, R1, #0xFF00  ; Set bits 8-15</p>
</code>`<code>

<strong>Clear bits 16-23</strong>

</code>`<code>assembly
<p>LDR R0, =0xFF00FFFF  ; Mask with bits 16-23 clear</p>
<p>AND R1, R1, R0       ; Clear bits 16-23 of R1</p>
</code>`<code>

<strong>Toggle bits 0-7</strong>

</code>`<code>assembly
<p>EOR R1, R1, #0xFF    ; Toggle lower byte</p>
</code>`<code>

<h3>4.3 Checking Flags</h3>

<strong>Check if any of bits 4-7 are set</strong>

</code>`<code>assembly
<p>AND R2, R1, #0xF0    ; Mask bits 4-7</p>
<p>CMP R2, #0           ; Check if zero</p>
<p>BNE bits_set         ; Branch if any bit was set</p>
</code>`<code>

<strong>Check if specific pattern matches</strong>

</code>`<code>assembly
<p>; Check if bits 8-11 are 0b1010</p>
<p>LSR R0, R1, #8       ; Position bits</p>
<p>AND R0, R0, #0xF     ; Mask 4 bits</p>
<p>CMP R0, #0xA         ; Compare with 0b1010</p>
<p>BEQ pattern_match</p>
</code>`<code>

<h3>4.4 Color Packing/Unpacking</h3>

<strong>Pack RGB values (8 bits each)</strong>

</code>`<code>assembly
<p>; R0 = Red, R1 = Green, R2 = Blue</p>
<p>LSL R1, R1, #8       ; Green << 8</p>
<p>LSL R2, R2, #16      ; Blue << 16</p>
<p>ORR R3, R0, R1       ; Combine Red and Green</p>
<p>ORR R3, R3, R2       ; Combine with Blue</p>
<p>; R3 now contains 0x00BBGGRR</p>
</code>`<code>

<strong>Unpack RGB values</strong>

</code>`<code>assembly
<p>; R0 contains 0x00BBGGRR</p>
<p>AND R1, R0, #0xFF      ; Extract Red</p>
<p>LSR R2, R0, #8</p>
<p>AND R2, R2, #0xFF      ; Extract Green</p>
<p>LSR R3, R0, #16</p>
<p>AND R3, R3, #0xFF      ; Extract Blue</p>
</code>``

<h2>Key Takeaways</h2>

<p>1. <strong>Unsigned binary integers</strong> represent values from 0 to 2^N - 1 using N bits.</p>

<p>2. <strong>Two's complement</strong> represents signed integers, with MSB as sign bit and range -(2^(N-1)) to +(2^(N-1) - 1).</p>

<p>3. <strong>Sign extension</strong> preserves value when expanding narrower signed values to wider registers.</p>

<p>4. <strong>Hexadecimal notation</strong> provides compact representation with one hex digit per 4 binary bits.</p>

<p>5. <strong>ARM instructions are fixed 32-bit length</strong>, simplifying fetch/decode but limiting immediate values.</p>

<p>6. <strong>Data processing format</strong> includes condition, opcode, source/destination registers, and operand.</p>

<p>7. <strong>Data transfer format</strong> specifies load/store, byte/word, addressing mode, and offset.</p>

<p>8. <strong>Immediate encoding</strong> uses 8-bit value + 4-bit rotation, limiting which constants can be encoded directly.</p>

<p>9. <strong>Bitwise AND</strong> used for masking (extracting specific bits) and clearing bits.</p>

<p>10. <strong>Bitwise OR</strong> used for setting specific bits and combining values.</p>

<p>11. <strong>Bitwise XOR</strong> used for toggling bits, fast zero, and comparisons.</p>

<p>12. <strong>Shift operations</strong> enable fast multiplication/division by powers of 2 and bit positioning.</p>

<p>13. <strong>Bit manipulation</strong> is fundamental for low-level programming, hardware control, and optimization.</p>

<p>14. <strong>Understanding encoding</strong> helps write efficient assembly and debug machine code issues.</p>

<h2>Summary</h2>

<p>Number representation and instruction encoding form the foundation of low-level programming. Two's complement enables efficient signed arithmetic with simple hardware, while sign extension preserves values across different data sizes. ARM's fixed 32-bit instruction format provides regularity but imposes constraints on immediate values, solved through clever encoding schemes. Logical operations—AND, OR, XOR, and NOT—combined with shift operations, provide powerful tools for bit manipulation essential in systems programming, embedded development, and performance optimization. Mastering these concepts enables efficient assembly programming and deeper understanding of how high-level operations translate to machine instructions. These fundamentals prepare us for more complex topics including branching, function calls, and memory management.</p>

            
            <div class="lecture-nav">
                <a href="lecture-04.html" class="nav-btn">← Previous Lecture</a>
                <a href="lecture-06.html" class="nav-btn">Next Lecture →</a>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 CO224 Computer Architecture Lecture Series. All rights reserved.</p>
            <p>Department of Computer Engineering, University of Peradeniya</p>
        </div>
    </footer>
</body>
</html>
