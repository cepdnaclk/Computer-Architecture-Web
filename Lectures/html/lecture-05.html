<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture 5: Number Representation and Data Processing - Lectures on Computer Architecture</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-asm6502.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
</head>
<body>
    <header class="lecture-header">
        <div class="container">
            <a href="../../index.html" class="back-link">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                Back to All Lectures
            </a>
            <h1 class="lecture-title">Lecture 5: Number Representation and Data Processing</h1>
            <p class="lecture-meta">Lectures on Computer Architecture</p>
        </div>
    </header>

    <main class="lecture-content-area container">
        <div class="content-body">
            <!-- Video Section -->
            <div class="video-container">
                <div class="video-thumbnail">
                    <a href="https://www.youtube.com/watch?v=rCS3oXcQPKo" target="_blank" class="video-play-overlay">
                        <img src="https://img.youtube.com/vi/rCS3oXcQPKo/maxresdefault.jpg" 
                             alt="Lecture 5 Video Thumbnail"
                             onerror="this.src='https://img.youtube.com/vi/rCS3oXcQPKo/hqdefault.jpg'">
                        <div class="play-button">
                            <svg width="68" height="48" viewBox="0 0 68 48" fill="none">
                                <path d="M66.52 7.74c-.78-2.93-2.49-5.41-5.42-6.19C55.79.13 34 0 34 0S12.21.13 6.9 1.55c-2.93.78-4.63 3.26-5.42 6.19C.06 13.05 0 24 0 24s.06 10.95 1.48 16.26c.78 2.93 2.49 5.41 5.42 6.19C12.21 47.87 34 48 34 48s21.79-.13 27.1-1.55c2.93-.78 4.64-3.26 5.42-6.19C67.94 34.95 68 24 68 24s-.06-10.95-1.48-16.26z" fill="red"/>
                                <path d="M45 24L27 14v20" fill="white"/>
                            </svg>
                        </div>
                    </a>
                </div>
                <div class="video-info">
                    <p class="video-notice">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="16" x2="12" y2="12"></line>
                            <line x1="12" y1="8" x2="12.01" y2="8"></line>
                        </svg>
                        Click the thumbnail above to watch the video lecture on YouTube
                    </p>
                </div>
            </div>

            
<em>By Dr. Kisaru Liyanage</em>

<h2>5.1 Introduction</h2>

<p>This lecture delves into how computers represent and manipulate data at the binary level. We explore number systems, two's complement representation for signed integers, instruction encoding formats in ARM assembly, and logical operations for bit manipulation. Understanding these fundamentals is essential for programming efficiently in assembly language and comprehending how processors execute arithmetic and logical operations.</p>


<h2>5.2 Number Representation Systems</h2>

<h3>5.2.1 Unsigned Binary Integers</h3>

<p><strong>Binary System Basics</strong></p>

<ul>
<li>Base-2 number system using digits 0 and 1</li>
<li>Each bit position represents a power of 2</li>
<li>Rightmost bit is least significant (LSB)</li>
<li>Leftmost bit is most significant (MSB)</li>
</ul>

<p><strong>Place Value Calculation</strong></p>

<div class="math-block">
$$
\begin{align*}
\text{Binary: } &1011 \\
\text{Value} &= (1 \times 2^3) + (0 \times 2^2) + (1 \times 2^1) + (1 \times 2^0) \\
&= 8 + 0 + 2 + 1 \\
&= 11 \text{ (decimal)}
\end{align*}
$$
</div>


<p><strong>N-Bit Unsigned Range</strong></p>

<ul>
<li>N bits can represent 2^N different values</li>
<li>Range: 0 to (2^N - 1)</li>
<li>8 bits: 0 to 255</li>
<li>32 bits: 0 to 4,294,967,295</li>
</ul>

<p><strong>Binary to Decimal Conversion</strong></p>

<div class="math-block">
$$
\begin{align*}
\text{Example: } &10110101 \\
&= 1 \times 128 + 0 \times 64 + 1 \times 32 + 1 \times 16 + 0 \times 8 + 1 \times 4 + 0 \times 2 + 1 \times 1 \\
&= 128 + 32 + 16 + 4 + 1 \\
&= 181
\end{align*}
$$
</div>


<h3>5.2.2 Two's Complement Representation</h3>

<p><strong>Purpose of Two's Complement</strong></p>

<ul>
<li>Represents both positive and negative integers</li>
<li>Simplifies hardware (same adder for signed/unsigned)</li>
<li>Unique zero representation</li>
<li>Natural overflow behavior</li>
</ul>

<p><strong>Sign Bit</strong></p>

<ul>
<li>MSB indicates sign</li>
<li>MSB = 0: Positive number</li>
<li>MSB = 1: Negative number</li>
</ul>

<p><strong>Positive Numbers</strong></p>

<ul>
<li>Same as unsigned binary</li>
<li>MSB is always 0</li>
<li>Example: +5 in 8 bits = 00000101</li>
</ul>

<p><strong>Negative Numbers</strong></p>

<ul>
<li>Represented as 2^N - |value|</li>
<li>Example: -5 in 8 bits:</li>
</ul>

<div class="math-block">
$$
2^8 - 5 = 256 - 5 = 251 = 11111011
$$
</div>


<p><strong>Two's Complement Conversion</strong></p>
<p>Method 1 (Invert and Add):</p>

<p>1. Write positive value in binary</p>
<p>2. Invert all bits (0→1, 1→0)</p>
<p>3. Add 1 to result</p>

<p>Example: -5 in 8 bits</p>

<pre><code>+5:        00000101
Invert:    11111010
Add 1:     11111011  (this is -5)
</code></pre>

<p>Method 2 (Subtraction):</p>

<div class="math-block">
$$
-5 = 2^8 - 5 = 256 - 5 = 251 = 11111011
$$
</div>


<p><strong>N-Bit Signed Range</strong></p>

<ul>
<li>Range: -(2^(N-1)) to +(2^(N-1) - 1)</li>
<li>8 bits: -128 to +127</li>
<li>32 bits: -2,147,483,648 to +2,147,483,647</li>
</ul>

<p><strong>Special Cases</strong></p>

<ul>
<li>Zero: 00000000 (unique representation)</li>
<li>Most negative: 10000000 (-128 in 8 bits)</li>
</ul>
<p>- Has no positive counterpart!</p>
<p>- Negating gives overflow</p>

<h3>5.2.3 Sign Extension</h3>

<p><strong>Purpose</strong></p>

<ul>
<li>Extend smaller signed value to larger width</li>
<li>Preserve numerical value</li>
<li>Required when loading bytes/halfwords into 32-bit registers</li>
</ul>

<p><strong>Process</strong></p>

<ul>
<li>Replicate the sign bit (MSB) to fill new bits</li>
<li>Preserves positive/negative value</li>
</ul>

<p><strong>Examples</strong></p>

<pre><code>8-bit to 32-bit:
00000101 (+5) → 00000000 00000000 00000000 00000101 (+5)
11111011 (-5) → 11111111 11111111 11111111 11111011 (-5)
</code></pre>

<p><strong>ARM Instructions for Sign Extension</strong></p>

<ul>
<li><strong>LDRH</strong>: Load halfword (16 bits), zero-extend to 32 bits</li>
<li><strong>LDRSH</strong>: Load signed halfword, sign-extend to 32 bits</li>
<li><strong>LDRB</strong>: Load byte (8 bits), zero-extend to 32 bits</li>
<li><strong>LDRSB</strong>: Load signed byte, sign-extend to 32 bits</li>
</ul>

<p><strong>Example Usage</strong></p>

<pre><code class="language-asm6502">LDRH R0, [R1]     ; R0 = 0x0000ABCD (zero-extended)
LDRSH R0, [R1]    ; R0 = 0xFFFFABCD (sign-extended if bit 15 = 1)
LDRB R0, [R1]     ; R0 = 0x000000AB (zero-extended)
LDRSB R0, [R1]    ; R0 = 0xFFFFFFAB (sign-extended if bit 7 = 1)
</code></pre>


<h3>5.2.4 Hexadecimal Notation</h3>

<p><strong>Why Hexadecimal?</strong></p>

<ul>
<li>Compact representation of binary</li>
<li>One hex digit = 4 binary bits</li>
<li>Easier to read than long binary strings</li>
<li>Common in programming and debugging</li>
</ul>

<p><strong>Hex Digits</strong></p>

<table>
<thead>
<tr>
<th>Binary</th>
<th>Hex</th>
<th>Decimal</th>
</tr>
</thead>
<tbody>
<tr><td>0000</td><td>0</td><td>0</td></tr>
<tr><td>0001</td><td>1</td><td>1</td></tr>
<tr><td>0010</td><td>2</td><td>2</td></tr>
<tr><td>0011</td><td>3</td><td>3</td></tr>
<tr><td>0100</td><td>4</td><td>4</td></tr>
<tr><td>0101</td><td>5</td><td>5</td></tr>
<tr><td>0110</td><td>6</td><td>6</td></tr>
<tr><td>0111</td><td>7</td><td>7</td></tr>
<tr><td>1000</td><td>8</td><td>8</td></tr>
<tr><td>1001</td><td>9</td><td>9</td></tr>
<tr><td>1010</td><td>A</td><td>10</td></tr>
<tr><td>1011</td><td>B</td><td>11</td></tr>
<tr><td>1100</td><td>C</td><td>12</td></tr>
<tr><td>1101</td><td>D</td><td>13</td></tr>
<tr><td>1110</td><td>E</td><td>14</td></tr>
<tr><td>1111</td><td>F</td><td>15</td></tr>
</tbody>
</table>


<p><strong>Conversion Examples</strong></p>

<pre><code>Binary: 1011 0110 1101 0010
Hex:      B    6    D    2
Result: 0xB6D2

Hex: 0x3F
Binary: 0011 1111
Decimal: 63
</code></pre>

<p><strong>ARM Hexadecimal Usage</strong></p>

<pre><code class="language-asm6502">MOV R0, #0xFF        ; R0 = 255
MOV R1, #0x100       ; R1 = 256
LDR R2, =0xDEADBEEF  ; R2 = 3735928559
</code></pre>


<h2>5.3 ARM Instruction Encoding</h2>

<h3>5.3.1 Fixed-Length Instructions</h3>

<p><strong>32-Bit Instruction Format</strong></p>

<ul>
<li>Every ARM instruction is exactly 32 bits</li>
<li>Simplifies instruction fetch and decode</li>
<li>Enables efficient pipelining</li>
</ul>

<p><strong>Advantages</strong></p>

<ul>
<li>Predictable instruction boundaries</li>
<li>Simple PC increment (always +4)</li>
<li>Fast decode logic</li>
</ul>

<p><strong>Trade-offs</strong></p>

<ul>
<li>Some instructions may "waste" bits</li>
<li>Immediate values limited in size</li>
<li>Code density lower than variable-length (e.g., x86)</li>
</ul>

<h3>5.3.2 Data Processing Instruction Format</h3>

<p><strong>Format Structure</strong></p>

<pre><code>[Cond][00][I][Opcode][S][Rn][Rd][Operand2]
4-bit 2  1   4-bit   1  4   4   12-bit
</code></pre>


<p><strong>Field Descriptions</strong></p>

<p><strong>Condition (4 bits, bits 28-31)</strong></p>

<ul>
<li>Conditional execution feature</li>
<li>0000 = EQ (equal, Z=1)</li>
<li>0001 = NE (not equal, Z=0)</li>
<li>1010 = GE (greater or equal, signed)</li>
<li>1110 = AL (always execute, default)</li>
</ul>

<p><strong>I bit (bit 25)</strong></p>

<ul>
<li>0 = Operand2 is register</li>
<li>1 = Operand2 is immediate value</li>
</ul>

<p><strong>Opcode (4 bits, bits 21-24)</strong></p>

<ul>
<li>Specifies operation (AND, EOR, SUB, ADD, etc.)</li>
<li>0100 = ADD</li>
<li>0010 = SUB</li>
<li>0000 = AND</li>
<li>1100 = ORR</li>
</ul>

<p><strong>S bit (bit 20)</strong></p>

<ul>
<li>0 = Don't update condition flags</li>
<li>1 = Update flags (CPSR)</li>
</ul>

<p><strong>Rn (4 bits, bits 16-19)</strong></p>

<ul>
<li>First operand register number</li>
<li>0000 = R0, 0001 = R1, etc.</li>
</ul>

<p><strong>Rd (4 bits, bits 12-15)</strong></p>

<ul>
<li>Destination register number</li>
</ul>

<p><strong>Operand2 (12 bits, bits 0-11)</strong></p>

<ul>
<li>If I=0: Shift amount and second register</li>
<li>If I=1: 8-bit immediate + 4-bit rotation</li>
</ul>

<p><strong>Example: ADD R0, R1, R2</strong></p>

<pre><code>Encoding fields:
  Cond: 1110 (always)
  I: 0 (register operand)
  Opcode: 0100 (ADD)
  S: 0 (don't update flags)
  Rn: 0001 (R1)
  Rd: 0000 (R0)
  Operand2: 0002 (R2, no shift)

Result: 0xE0810002
</code></pre>


<h3>5.3.3 Data Transfer Instruction Format</h3>

<p><strong>Format Structure</strong></p>

<pre><code>[Cond][01][I][P][U][B][W][L][Rn][Rd][Offset]
4-bit 2  1  1  1  1  1  1  4   4   12-bit
</code></pre>


<p><strong>Key Fields</strong></p>

<p><strong>L bit (bit 20)</strong></p>

<ul>
<li>0 = Store (STR)</li>
<li>1 = Load (LDR)</li>
</ul>

<p><strong>B bit (bit 22)</strong></p>

<ul>
<li>0 = Word transfer (32 bits)</li>
<li>1 = Byte transfer (8 bits)</li>
</ul>

<p><strong>P bit (bit 24)</strong></p>

<ul>
<li>0 = Post-indexed addressing</li>
<li>1 = Pre-indexed or offset addressing</li>
</ul>

<p><strong>U bit (bit 23)</strong></p>

<ul>
<li>0 = Subtract offset from base</li>
<li>1 = Add offset to base</li>
</ul>

<p><strong>W bit (bit 21)</strong></p>

<ul>
<li>0 = No write-back</li>
<li>1 = Write-back (update base register)</li>
</ul>

<p><strong>Rn (base register)</strong></p>

<ul>
<li>Contains memory address or base address</li>
</ul>

<p><strong>Rd (data register)</strong></p>

<ul>
<li>For Load: Destination register</li>
<li>For Store: Source register</li>
</ul>

<p><strong>Offset (12 bits)</strong></p>

<ul>
<li>Memory address offset</li>
<li>Can be immediate or register</li>
</ul>

<p><strong>Example: LDR R0, [R1, #4]</strong></p>

<pre><code>Encoding fields:
  Cond: 1110 (always)
  L: 1 (load)
  B: 0 (word)
  P: 1 (offset addressing)
  U: 1 (add offset)
  Rn: 0001 (R1)
  Rd: 0000 (R0)
  Offset: 004 (immediate 4)

Result: 0xE5910004
</code></pre>


<h3>5.3.4 Immediate Value Encoding</h3>

<p><strong>Challenge</strong></p>

<ul>
<li>32-bit instruction must fit: opcode, registers, immediate</li>
<li>Cannot fit full 32-bit immediate</li>
</ul>

<p><strong>ARM Solution: 8-bit + 4-bit Rotation</strong></p>

<ul>
<li>Immediate field: 12 bits total</li>
<li>Lower 8 bits: Immediate value (0-255)</li>
<li>Upper 4 bits: Rotation amount (0-15)</li>
<li>Rotation: Right by (2 × rotation field) bits</li>
</ul>

<p><strong>Calculation</strong></p>

<div class="math-block">
$$
\text{Actual Value} = \text{Immediate} \times \text{ROR}(2 \times \text{Rotation})
$$
</div>

<p><strong>Examples</strong></p>

<pre><code>Immediate=0xFF, Rotation=0:
Value = 0xFF ROR 0 = 0x000000FF

Immediate=0xFF, Rotation=8:
Value = 0xFF ROR 16 = 0x00FF0000

Immediate=0xFF, Rotation=12:
Value = 0xFF ROR 24 = 0xFF000000
</code></pre>


<p><strong>Allowed Immediates</strong></p>

<ul>
<li>Not all 32-bit values can be encoded</li>
<li>Valid: 0xFF, 0xFF00, 0xFF0000, 0xFF000000</li>
<li>Valid: 0xFF000000FF (rotation wraps around)</li>
<li>Invalid: 0x123 (cannot be formed by rotation)</li>
</ul>

<p><strong>Assembler Handling</strong></p>

<ul>
<li>Assembler checks if immediate is valid</li>
<li>Gives error if immediate cannot be encoded</li>
<li>Use LDR pseudo-instruction for arbitrary values:</li>
</ul>

<pre><code class="language-asm6502">LDR R0, =0x12345678  ; Loads from literal pool
</code></pre>


<h2>5.4 Logical Operations</h2>

<h3>5.4.1 Bitwise AND</h3>

<p><strong>Operation</strong></p>

<ul>
<li>Performs logical AND on each bit pair</li>
<li>Result bit = 1 only if both input bits are 1</li>
</ul>

<p><strong>Truth Table</strong></p>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A AND B</th>
</tr>
</thead>
<tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
</tbody>
</table>

<p><strong>ARM Instruction</strong></p>

<pre><code class="language-asm6502">AND Rd, Rn, Rm       ; Rd = Rn AND Rm
AND Rd, Rn, #imm     ; Rd = Rn AND immediate
</code></pre>


<p><strong>Common Uses</strong></p>

<p><strong>Bit Masking (Extract Specific Bits)</strong></p>

<pre><code class="language-asm6502">; Extract lower 8 bits of R1
MOV R0, R1
AND R0, R0, #0xFF    ; R0 = R1 & 0xFF (keep bits 0-7)

; Extract bits 8-15
MOV R0, R1
AND R0, R0, #0xFF00  ; R0 = R1 & 0xFF00 (keep bits 8-15)
</code></pre>

<p><strong>Clearing Specific Bits</strong></p>

<pre><code class="language-asm6502">; Clear bit 5 of R1
AND R1, R1, #0xFFFFFFDF  ; Bit 5 mask: ~(1 << 5)
</code></pre>

<p><strong>Checking if Bit Set</strong></p>

<pre><code class="language-asm6502">AND R2, R1, #0x80    ; Check if bit 7 is set
CMP R2, #0           ; Compare with zero
BEQ bit_clear        ; Branch if bit was clear
</code></pre>


<h3>5.4.2 Bitwise OR</h3>

<p><strong>Operation</strong></p>

<ul>
<li>Performs logical OR on each bit pair</li>
<li>Result bit = 1 if either input bit is 1</li>
</ul>

<p><strong>Truth Table</strong></p>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A OR B</th>
</tr>
</thead>
<tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
</tbody>
</table>

<p><strong>ARM Instruction</strong></p>

<pre><code class="language-asm6502">ORR Rd, Rn, Rm       ; Rd = Rn OR Rm (ORR in ARM)
ORR Rd, Rn, #imm     ; Rd = Rn OR immediate
</code></pre>

<p><strong>Common Uses</strong></p>

<p><strong>Setting Specific Bits</strong></p>

<pre><code class="language-asm6502">; Set bit 3 of R1
ORR R1, R1, #0x08    ; Bit 3 mask: (1 << 3) = 0x08

; Set bits 4 and 5
ORR R1, R1, #0x30    ; Mask: 0x30 = 0b00110000
</code></pre>

<p><strong>Combining Values</strong></p>

<pre><code class="language-asm6502">; Combine lower byte of R1 with upper bytes of R2
AND R1, R1, #0xFF        ; Keep only lower byte
AND R2, R2, #0xFFFFFF00  ; Keep only upper bytes
ORR R0, R1, R2           ; Combine
</code></pre>


<h3>5.4.3 Bitwise XOR (Exclusive OR)</h3>

<p><strong>Operation</strong></p>

<ul>
<li>Performs logical XOR on each bit pair</li>
<li>Result bit = 1 if input bits differ</li>
</ul>

<p><strong>Truth Table</strong></p>

<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A XOR B</th>
</tr>
</thead>
<tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td></tr>
</tbody>
</table>

<p><strong>ARM Instruction</strong></p>

<pre><code class="language-asm6502">EOR Rd, Rn, Rm       ; Rd = Rn EOR Rm (EOR in ARM)
EOR Rd, Rn, #imm     ; Rd = Rn EOR immediate
</code></pre>


<p><strong>Common Uses</strong></p>

<p><strong>Toggling Specific Bits</strong></p>

<pre><code class="language-asm6502">; Toggle bit 2 of R1
EOR R1, R1, #0x04    ; Bit 2 mask: (1 << 2)
; If bit was 0, becomes 1; if was 1, becomes 0
</code></pre>

<p><strong>Fast Zero</strong></p>

<pre><code class="language-asm6502">EOR R0, R0, R0       ; R0 = 0 (XOR with itself)
</code></pre>

<p><strong>Comparison</strong></p>

<pre><code class="language-asm6502">; Check if R1 and R2 are equal
EOR R3, R1, R2       ; R3 = R1 XOR R2
CMP R3, #0           ; If R3 = 0, R1 == R2
BEQ values_equal
</code></pre>

<p><strong>Swapping Without Temporary</strong></p>

<pre><code class="language-asm6502">; Swap R0 and R1 without using another register
EOR R0, R0, R1
EOR R1, R0, R1
EOR R0, R0, R1
; Now R0 and R1 are swapped
</code></pre>


<h3>5.4.4 Bitwise NOT</h3>

<p><strong>Operation</strong></p>

<ul>
<li>Inverts all bits (0→1, 1→0)</li>
<li>Also called complement</li>
</ul>

<p><strong>ARM Instruction</strong></p>

<pre><code class="language-asm6502">MVN Rd, Rm           ; Rd = NOT Rm (Move Not)
MVN Rd, #imm         ; Rd = NOT immediate
</code></pre>

<p><strong>Common Uses</strong></p>

<p><strong>Creating Bit Masks</strong></p>

<pre><code class="language-asm6502">; Create mask with all bits set except bit 3
MOV R0, #0x08        ; 0x08 = 0b00001000
MVN R1, R0           ; R1 = 0xFFFFFFF7 (all except bit 3)
</code></pre>

<p><strong>Negation (with ADD)</strong></p>

<pre><code class="language-asm6502">; Negate R1 (two's complement)
MVN R1, R1           ; Invert all bits
ADD R1, R1, #1       ; Add 1
; Now R1 = -R1 (original)
</code></pre>


<h3>5.4.5 Shift Operations</h3>

<p><strong>Logical Shift Left (LSL)</strong></p>

<pre><code class="language-asm6502">LSL Rd, Rn, #shift   ; Rd = Rn << shift
MOV Rd, Rn, LSL #shift
</code></pre>


<ul>
<li>Shifts bits left, fills right with zeros</li>
<li>Each shift left multiplies by 2</li>
<li>Example: 0b00001010 LSL 2 = 0b00101000</li>
</ul>

<p><strong>Logical Shift Right (LSR)</strong></p>

<pre><code class="language-asm6502">LSR Rd, Rn, #shift   ; Rd = Rn >> shift (unsigned)
MOV Rd, Rn, LSR #shift
</code></pre>

<ul>
<li>Shifts bits right, fills left with zeros</li>
<li>Each shift right divides by 2 (unsigned)</li>
<li>Example: 0b10100000 LSR 2 = 0b00101000</li>
</ul>

<p><strong>Arithmetic Shift Right (ASR)</strong></p>

<pre><code class="language-asm6502">ASR Rd, Rn, #shift   ; Rd = Rn >> shift (signed)
</code></pre>

<ul>
<li>Shifts bits right, fills left with sign bit</li>
<li>Preserves sign for signed division</li>
<li>Example: 0b11110000 ASR 2 = 0b11111100 (sign preserved)</li>
</ul>

<p><strong>Rotate Right (ROR)</strong></p>

<pre><code class="language-asm6502">ROR Rd, Rn, #shift   ; Rotate Rn right by shift
</code></pre>


<ul>
<li>Bits shifted out right reappear at left</li>
<li>No information lost</li>
<li>Example: 0b10000001 ROR 1 = 0b11000000</li>
</ul>

<p><strong>Common Shift Applications</strong></p>

<p><strong>Fast Multiplication/Division by Powers of 2</strong></p>

<pre><code class="language-asm6502">LSL R0, R1, #3       ; R0 = R1 × 8 (2^3)
LSR R0, R1, #2       ; R0 = R1 / 4 (unsigned)
ASR R0, R1, #2       ; R0 = R1 / 4 (signed)
</code></pre>

<p><strong>Bit Extraction</strong></p>

<pre><code class="language-asm6502">; Extract bits 8-11 from R1
LSR R0, R1, #8       ; Shift bits 8-11 to bits 0-3
AND R0, R0, #0xF     ; Mask to keep only 4 bits
</code></pre>

<p><strong>Bit Positioning</strong></p>

<pre><code class="language-asm6502">; Move bit 0 to bit 7
LSL R0, R1, #7       ; Shift left 7 positions
AND R0, R0, #0x80    ; Keep only bit 7
</code></pre>


<h2>5.5 Practical Bit Manipulation Examples</h2>

<h3>5.5.1 Extracting Bit Fields</h3>

<p><strong>Extract bits 16-23</strong></p>

<pre><code class="language-asm6502">LSR R0, R1, #16      ; Shift right to position
AND R0, R0, #0xFF    ; Mask to 8 bits
</code></pre>

<p><strong>Extract bits 4-9 (6 bits)</strong></p>

<pre><code class="language-asm6502">LSR R0, R1, #4       ; Shift to position 0
AND R0, R0, #0x3F    ; Mask to 6 bits (0b111111)
</code></pre>


<h3>5.5.2 Setting and Clearing Bits</h3>

<p><strong>Set bits 8-15</strong></p>

<pre><code class="language-asm6502">ORR R1, R1, #0xFF00  ; Set bits 8-15
</code></pre>

<p><strong>Clear bits 16-23</strong></p>

<pre><code class="language-asm6502">LDR R0, =0xFF00FFFF  ; Mask with bits 16-23 clear
AND R1, R1, R0       ; Clear bits 16-23 of R1
</code></pre>

<p><strong>Toggle bits 0-7</strong></p>

<pre><code class="language-asm6502">EOR R1, R1, #0xFF    ; Toggle lower byte
</code></pre>


<h3>5.5.3 Checking Flags</h3>

<p><strong>Check if any of bits 4-7 are set</strong></p>

<pre><code class="language-asm6502">AND R2, R1, #0xF0    ; Mask bits 4-7
CMP R2, #0           ; Check if zero
BNE bits_set         ; Branch if any bit was set
</code></pre>

<p><strong>Check if specific pattern matches</strong></p>

<pre><code class="language-asm6502">; Check if bits 8-11 are 0b1010
LSR R0, R1, #8       ; Position bits
AND R0, R0, #0xF     ; Mask 4 bits
CMP R0, #0xA         ; Compare with 0b1010
BEQ pattern_match
</code></pre>


<h3>5.5.4 Color Packing/Unpacking</h3>

<p><strong>Pack RGB values (8 bits each)</strong></p>

<pre><code class="language-asm6502">; R0 = Red, R1 = Green, R2 = Blue
LSL R1, R1, #8       ; Green << 8
LSL R2, R2, #16      ; Blue << 16
ORR R3, R0, R1       ; Combine Red and Green
ORR R3, R3, R2       ; Combine with Blue
; R3 now contains 0x00BBGGRR
</code></pre>


<p><strong>Unpack RGB values</strong></p>

<pre><code class="language-asm6502">; R0 contains 0x00BBGGRR
AND R1, R0, #0xFF      ; Extract Red
LSR R2, R0, #8
AND R2, R2, #0xFF      ; Extract Green
LSR R3, R0, #16
AND R3, R3, #0xFF      ; Extract Blue
</code></pre>


<h2>Key Takeaways</h2>

<ol>
<li><strong>Unsigned binary integers</strong> represent values from 0 to 2^N - 1 using N bits.</li>

<li><strong>Two's complement</strong> represents signed integers, with MSB as sign bit and range -(2^(N-1)) to +(2^(N-1) - 1).</li>

<li><strong>Sign extension</strong> preserves value when expanding narrower signed values to wider registers.</li>

<li><strong>Hexadecimal notation</strong> provides compact representation with one hex digit per 4 binary bits.</li>

<li><strong>ARM instructions are fixed 32-bit length</strong>, simplifying fetch/decode but limiting immediate values.</li>

<li><strong>Data processing format</strong> includes condition, opcode, source/destination registers, and operand.</li>

<li><strong>Data transfer format</strong> specifies load/store, byte/word, addressing mode, and offset.</li>

<li><strong>Immediate encoding</strong> uses 8-bit value + 4-bit rotation, limiting which constants can be encoded directly.</li>

<li><strong>Bitwise AND</strong> used for masking (extracting specific bits) and clearing bits.</li>

<li><strong>Bitwise OR</strong> used for setting specific bits and combining values.</li>

<li><strong>Bitwise XOR</strong> used for toggling bits, fast zero, and comparisons.</li>

<li><strong>Shift operations</strong> enable fast multiplication/division by powers of 2 and bit positioning.</li>

<li><strong>Bit manipulation</strong> is fundamental for low-level programming, hardware control, and optimization.</li>

<li><strong>Understanding encoding</strong> helps write efficient assembly and debug machine code issues.</li>
</ol>

<h2>Summary</h2>

<p>Number representation and instruction encoding form the foundation of low-level programming. Two's complement enables efficient signed arithmetic with simple hardware, while sign extension preserves values across different data sizes. ARM's fixed 32-bit instruction format provides regularity but imposes constraints on immediate values, solved through clever encoding schemes. Logical operations—AND, OR, XOR, and NOT—combined with shift operations, provide powerful tools for bit manipulation essential in systems programming, embedded development, and performance optimization. Mastering these concepts enables efficient assembly programming and deeper understanding of how high-level operations translate to machine instructions. These fundamentals prepare us for more complex topics including branching, function calls, and memory management.</p>

            
            <div class="lecture-nav">
                <a href="lecture-04.html" class="nav-btn">← Previous Lecture</a>
                <a href="lecture-06.html" class="nav-btn">Next Lecture →</a>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 CO224 Computer Architecture Lecture Series. All rights reserved.</p>
            <p>Department of Computer Engineering, University of Peradeniya</p>
        </div>
    </footer>
</body>
</html>
