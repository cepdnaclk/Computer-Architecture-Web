<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lecture 7: Function Call and Return - Lectures on Computer Architecture</title>
    <link rel="stylesheet" href="../../assets/css/style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
            onload="renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false}
                ]
            });"></script>
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

    <!-- Prism.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-asm6502.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js"></script>
</head>
<body>
    <header class="lecture-header">
        <div class="container">
            <a href="../../index.html" class="back-link">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
                Back to All Lectures
            </a>
            <h1 class="lecture-title">Lecture 7: Function Call and Return</h1>
            <p class="lecture-meta">Lectures on Computer Architecture</p>
        </div>
    </header>

    <main class="lecture-content-area container">
        <div class="content-body">
            <!-- Video Section -->
            <div class="video-container">
                <div class="video-thumbnail">
                    <a href="https://www.youtube.com/watch?v=T99xSt2ryKs" target="_blank" class="video-play-overlay">
                        <img src="https://img.youtube.com/vi/T99xSt2ryKs/maxresdefault.jpg" 
                             alt="Lecture 7 Video Thumbnail"
                             onerror="this.src='https://img.youtube.com/vi/T99xSt2ryKs/hqdefault.jpg'">
                        <div class="play-button">
                            <svg width="68" height="48" viewBox="0 0 68 48" fill="none">
                                <path d="M66.52 7.74c-.78-2.93-2.49-5.41-5.42-6.19C55.79.13 34 0 34 0S12.21.13 6.9 1.55c-2.93.78-4.63 3.26-5.42 6.19C.06 13.05 0 24 0 24s.06 10.95 1.48 16.26c.78 2.93 2.49 5.41 5.42 6.19C12.21 47.87 34 48 34 48s21.79-.13 27.1-1.55c2.93-.78 4.64-3.26 5.42-6.19C67.94 34.95 68 24 68 24s-.06-10.95-1.48-16.26z" fill="red"/>
                                <path d="M45 24L27 14v20" fill="white"/>
                            </svg>
                        </div>
                    </a>
                </div>
                <div class="video-info">
                    <p class="video-notice">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"></circle>
                            <line x1="12" y1="16" x2="12" y2="12"></line>
                            <line x1="12" y1="8" x2="12.01" y2="8"></line>
                        </svg>
                        Click the thumbnail above to watch the video lecture on YouTube
                    </p>
                </div>
            </div>

            
<em>By Dr. Kisaru Liyanage</em>

<h2>7.1 Introduction</h2>

<p>Function calling is a fundamental mechanism that enables modular programming and code reuse. This lecture explores how ARM assembly implements function calls, covering parameter passing, return value handling, the call stack, register preservation conventions, and recursion. Understanding these mechanisms is essential for translating high-level function-based programs into assembly and for comprehending how processors manage execution context across function boundaries.</p>


<h2>7.2 Function Calling Fundamentals</h2>

<h3>7.2.1 Function Calling Steps</h3>

<p><strong>Complete Call Sequence</strong></p>

<ol>
<li><strong>Place parameters</strong> in argument registers (R0-R3)</li>
<li><strong>Transfer control</strong> to callee function using BL</li>
<li><strong>Acquire stack storage</strong> for temporary values</li>
<li><strong>Back up registers</strong> that need preservation (R4-R11)</li>
<li><strong>Perform function operations</strong> (the actual work)</li>
<li><strong>Place result</strong> in return register (R0)</li>
<li><strong>Restore backed-up registers</strong> from stack</li>
<li><strong>Return to caller</strong> using MOV PC, LR</li>
</ol>

<p><strong>Why This Complexity?</strong></p>

<ul>
<li>Enables nested and recursive function calls</li>
<li>Protects caller's data in registers</li>
<li>Provides local storage for function variables</li>
<li>Supports arbitrary call depth</li>
</ul>

<h3>7.2.2 Why Use Functions?</h3>

<p><strong>Benefits</strong></p>

<ul>
<li><strong>Code reuse</strong>: Write once, call many times</li>
<li><strong>Modularity</strong>: Break complex problems into manageable pieces</li>
<li><strong>Abstraction</strong>: Hide implementation details</li>
<li><strong>Maintainability</strong>: Easier to debug and modify</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-c">int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(5, 3);  // Function call
}
</code></pre>

<h2>7.3 ARM Register Conventions</h2>

<h3>7.3.1 Register Usage Rules</h3>

<p><strong>Register Classification</strong></p>

<pre><code class="language-asm6502">R0-R1:   Arguments and return results
         - Caller does NOT expect these preserved
         - Scratch registers

R2-R3:   Additional arguments
         - Also scratch registers
         - Caller does NOT expect preservation

R4-R11:  Local variables
         - MUST be preserved across function calls
         - Callee saves if it uses these registers

R12:     Intra-procedure-call scratch register
         - Can be corrupted by function calls
         - Not preserved

R13 (SP): Stack Pointer
          - Points to top of stack
          - MUST always be valid

R14 (LR): Link Register
          - Stores return address
          - Set by BL instruction

R15 (PC): Program Counter
          - Next instruction address
          - Modified to return from function
</code></pre>


<h3>7.3.2 Shared Register File</h3>

<p><strong>Key Concept</strong></p>

<ul>
<li>ALL functions share the SAME 16 registers</li>
<li>No separate register sets per function</li>
<li>Registers are a shared resource requiring careful management</li>
</ul>

<p><strong>Implications</strong></p>

<ul>
<li>Functions must coordinate register usage</li>
<li>Conventions prevent conflicts</li>
<li>Callee must preserve certain registers (R4-R11)</li>
<li>Caller can assume R4-R11 unchanged after call</li>
</ul>

<p><strong>Example Scenario</strong></p>

<pre><code class="language-asm6502">main:
MOV R4, #10      ; main uses R4
MOV R0, #5       ; Pass argument
BL function      ; Call function
; R4 still contains 10 (guaranteed)
ADD R5, R4, R0   ; Use preserved R4 and return value

function:
; Must preserve R4 if we use it
; Can freely modify R0-R3, R12
MOV R0, #20      ; Return value
MOV PC, LR       ; Return
</code></pre>

<h2>7.4 Function Call Instructions</h2>

<h3>7.4.1 Branch and Link (BL)</h3>

<p><strong>Syntax</strong></p>

<pre><code class="language-asm6502">BL function_label    ; Branch and Link
</code></pre>

<p><strong>Operation</strong></p>

<ol>
<li><strong>Save return address</strong>: LR = address of next instruction</li>
<li><strong>Jump to function</strong>: PC = function_label address</li>
</ol>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">MOV R0, #10      ; Address: 0x1000
BL fun           ; Address: 0x1004
ADD R1, R0, #5   ; Address: 0x1008 (return point)


fun:
; LR contains 0x1008 (address after BL)
; Function code here
MOV PC, LR       ; Return to 0x1008
</code></pre>

<p><strong>Why "Link"?</strong></p>

<ul>
<li>Creates a "link" back to caller</li>
<li>LR provides the connection</li>
<li>Enables function to return</li>
</ul>

<h3>7.4.2 Return from Function</h3>

<p><strong>Basic Return</strong></p>

<pre><code class="language-asm6502">MOV PC, LR           ; Copy LR to PC
</code></pre>

<p><strong>Operation</strong></p>

<ul>
<li>PC = LR (jump to return address)</li>
<li>Execution continues at instruction after BL</li>
<li>Simple and fast</li>
</ul>

<p><strong>Alternative (older ARM)</strong></p>

<pre><code class="language-asm6502">BX LR                ; Branch and Exchange
</code></pre>

<h2>7.5 Parameter Passing</h2>

<h3>7.5.1 Using R0-R3</h3>

<p><strong>Convention</strong></p>

<ul>
<li>First 4 arguments in R0-R3</li>
<li>Arguments loaded before BL instruction</li>
<li>Callee reads R0-R3 to get parameters</li>
</ul>

<p><strong>Example: Two Parameters</strong></p>

<pre><code class="language-c">int multiply(int a, int b) {
    return a * b;
}

int result = multiply(6, 7);
</code></pre>

<p><strong>ARM Assembly</strong></p>

<pre><code class="language-asm6502">MOV R0, #6       ; First argument (a)
MOV R1, #7       ; Second argument (b)
BL multiply      ; Call function
; R0 now contains result (42)


multiply:
MUL R0, R0, R1   ; R0 = R0 × R1
MOV PC, LR       ; Return
</code></pre>

<h3>7.5.2 More Than 4 Arguments</h3>

<p><strong>Solution: Use Stack</strong></p>

<ul>
<li>Arguments 1-4 in R0-R3</li>
<li>Additional arguments pushed to stack</li>
<li>Callee reads from stack</li>
</ul>

<p><strong>Example: 6 Arguments</strong></p>

<pre><code class="language-c">int sum6(int a, int b, int c, int d, int e, int f) {
    return a + b + c + d + e + f;
}
</code></pre>

<p><strong>ARM Assembly</strong></p>

<pre><code class="language-asm6502">MOV R0, #1       ; arg1
MOV R1, #2       ; arg2
MOV R2, #3       ; arg3
MOV R3, #4       ; arg4
MOV R4, #5
MOV R5, #6
SUB SP, SP, #8   ; Space for 2 more args
STR R4, [SP, #0] ; arg5 on stack
STR R5, [SP, #4] ; arg6 on stack
BL sum6
ADD SP, SP, #8   ; Clean up stack


sum6:
; R0-R3 have first 4 args
; Load arg5 and arg6 from stack
LDR R4, [SP, #0] ; arg5
LDR R5, [SP, #4] ; arg6
ADD R0, R0, R1
ADD R0, R0, R2
ADD R0, R0, R3
ADD R0, R0, R4
ADD R0, R0, R5
MOV PC, LR
</code></pre>

<h2>7.6 Return Values</h2>

<h3>7.6.1 Primary Return Register (R0)</h3>

<p><strong>Convention</strong></p>

<ul>
<li>Result placed in R0</li>
<li>Caller reads R0 after function returns</li>
<li>Works for 32-bit values</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-asm6502">add:
ADD R0, R0, R1   ; R0 = R0 + R1
MOV PC, LR       ; Return with result in R0

main:
MOV R0, #10
MOV R1, #20
BL add           ; Call function
; R0 now contains 30
</code></pre>

<h3>7.6.2 64-Bit Return Values</h3>

<p><strong>Convention</strong></p>

<ul>
<li>Lower 32 bits in R0</li>
<li>Upper 32 bits in R1</li>
<li>Example: 64-bit integer or two 32-bit values</li>
</ul>

<p><strong>Example</strong></p>

<pre><code class="language-c">long long multiply64(int a, int b) {
    return (long long)a * b;
}
</code></pre>

<p><strong>ARM Assembly</strong></p>

<pre><code class="language-asm6502">multiply64:
SMULL R0, R1, R0, R1  ; Signed multiply long
; R0 = lower 32 bits
; R1 = upper 32 bits
MOV PC, LR
</code></pre>


<h2>7.7 The Stack</h2>

<h3>7.7.1 Stack Structure</h3>

<p><strong>Definition</strong></p>

<ul>
<li>Last In, First Out (LIFO) data structure</li>
<li>Part of main memory</li>
<li>Used for temporary storage</li>
</ul>

<p><strong>Characteristics</strong></p>

<ul>
<li><strong>Starts at high address</strong>: Top of memory</li>
<li><strong>Grows downward</strong>: Toward lower addresses</li>
<li><strong>Stack Pointer (SP/R13)</strong>: Points to top of stack</li>
<li><strong>Dynamic size</strong>: Grows and shrinks as needed</li>
</ul>

<p><strong>Memory Layout</strong></p>

<pre><code>High Address
┌─────────┐
│  Stack  │ ← SP points here
│   ↓     │   (grows downward)
│         │
├─────────┤
│  Heap   │
│   ↑     │   (grows upward)
├─────────┤
│  Data   │   (static variables)
├─────────┤
│  Text   │   (instructions)
└─────────┘
Low Address
</code></pre>


<h3>7.7.2 Stack Uses</h3>

<p><strong>Primary Purposes</strong></p>

<ol>
<li><strong>Saving register values</strong> (preserve R4-R11)</li>
<li><strong>Storing local variables</strong> (arrays, structures)</li>
<li><strong>Preserving return addresses</strong> (nested calls)</li>
<li><strong>Extra function arguments</strong> (beyond R0-R3)</li>
<li><strong>Storing local arrays</strong> that don't fit in registers</li>
</ol>

<h2>7.8 Stack Operations</h2>

<h3>7.8.1 Allocating Stack Space (Pushing)</h3>

<p><strong>Decrement Stack Pointer</strong></p>

<pre><code class="language-asm6502">SUB SP, SP, #4       ; Allocate 4 bytes (1 register)
SUB SP, SP, #12      ; Allocate 12 bytes (3 registers)
</code></pre>


<p><strong>Why Subtract?</strong></p>

<ul>
<li>Stack grows toward lower addresses</li>
<li>Allocating space moves SP downward</li>
<li>Each 32-bit register needs 4 bytes</li>
</ul>

<h3>7.8.2 Storing Values to Stack</h3>

<p><strong>Single Register</strong></p>

<pre><code class="language-asm6502">SUB SP, SP, #4       ; Allocate space
STR R4, [SP, #0]     ; Store R4 at top of stack
</code></pre>


<p><strong>Multiple Registers</strong></p>

<pre><code class="language-asm6502">SUB SP, SP, #12      ; Space for 3 registers
STR R4, [SP, #0]     ; Store R4
STR R5, [SP, #4]     ; Store R5
STR R6, [SP, #8]     ; Store R6
</code></pre>

<p><strong>Push Multiple (Convenient)</strong></p>

<pre><code class="language-asm6502">PUSH {R4-R6}         ; Allocate and store in one instruction
</code></pre>


<h3>7.8.3 Loading Values from Stack</h3>

<p><strong>Single Register</strong></p>

<pre><code class="language-asm6502">LDR R4, [SP, #0]     ; Load R4 from stack
ADD SP, SP, #4       ; Release space
</code></pre>


<p><strong>Multiple Registers</strong></p>

<pre><code class="language-asm6502">LDR R4, [SP, #0]     ; Restore R4
LDR R5, [SP, #4]     ; Restore R5
LDR R6, [SP, #8]     ; Restore R6
ADD SP, SP, #12      ; Release space
</code></pre>

<p><strong>Pop Multiple</strong></p>

<pre><code class="language-asm6502">POP {R4-R6}          ; Restore and release in one instruction
</code></pre>


<h3>7.8.4 Stack Space Lifecycle</h3>

<p><strong>Pattern</strong></p>

<ol>
<li><strong>Allocate</strong>: SUB SP, SP, #n</li>
<li><strong>Use</strong>: STR/LDR with [SP, offset]</li>
<li><strong>Release</strong>: ADD SP, SP, #n</li>
</ol>

<p><strong>Important: Balance</strong></p>

<ul>
<li>Every SUB must have corresponding ADD</li>
<li>Unbalanced stack causes bugs and crashes</li>
<li>SP must be restored before return</li>
</ul>

<h2>7.9 Register Preservation</h2>

<h3>7.9.1 Why Preserve R4-R11?</h3>

<p><strong>Problem</strong></p>

<ul>
<li>All functions share same registers</li>
<li>Main function may be using R4-R11</li>
<li>Called function needs registers for its work</li>
<li>Must not corrupt caller's data</li>
</ul>

<p><strong>Solution</strong></p>

<ul>
<li>Callee saves R4-R11 to stack at function start</li>
<li>Uses registers freely during execution</li>
<li>Restores R4-R11 from stack before return</li>
<li>Caller expects R4-R11 unchanged</li>
</ul>

<h3>7.9.2 Preservation Pattern</h3>

<p><strong>Function Template</strong></p>

<pre><code class="language-asm6502">function:
; Prologue: Save registers
SUB SP, SP, #12      ; Allocate space
STR R4, [SP, #0]     ; Save R4
STR R5, [SP, #4]     ; Save R5
STR R6, [SP, #8]     ; Save R6

; Function body: Use R4-R6 freely
; ...

; Epilogue: Restore registers
LDR R4, [SP, #0]     ; Restore R4
LDR R5, [SP, #4]     ; Restore R5
LDR R6, [SP, #8]     ; Restore R6
ADD SP, SP, #12      ; Release space
MOV PC, LR           ; Return
</code></pre>


<p><strong>Optimization</strong></p>

<ul>
<li>Only preserve registers actually used</li>
<li>If function doesn't use R5, don't save/restore it</li>
<li>Saves stack space and execution time</li>
</ul>

<h2>7.10 Nested Function Calls (Non-Leaf Functions)</h2>

<h3>7.10.1 The Problem</h3>

<p><strong>Leaf Function</strong></p>

<ul>
<li>Doesn't call other functions</li>
<li>LR preserved automatically (not overwritten)</li>
<li>Simple return: MOV PC, LR</li>
</ul>

<p><strong>Non-Leaf Function</strong></p>

<ul>
<li>Calls other functions</li>
<li>BL overwrites LR with new return address</li>
<li>Original LR lost!</li>
<li>Cannot return to original caller</li>
</ul>

<p><strong>Example Problem</strong></p>

<pre><code class="language-asm6502">main:
BL funcA         ; LR = address after this BL

funcA:
; LR contains return address to main
BL funcB         ; LR OVERWRITTEN with return to funcA!
MOV PC, LR       ; Returns to funcA, not main (WRONG!)

funcB:
MOV PC, LR       ; Correctly returns to funcA
</code></pre>


<h3>7.10.2 Solution: Save LR to Stack</h3>

<p><strong>Pattern</strong></p>

<pre><code class="language-asm6502">function:
; Save LR first!
SUB SP, SP, #4
STR LR, [SP, #0]

; Now safe to call other functions
BL other_function

; Restore LR before return
LDR LR, [SP, #0]
ADD SP, SP, #4
MOV PC, LR
</code></pre>


<p><strong>Complete Example</strong></p>

<pre><code class="language-asm6502">main:
MOV R0, #5
BL outer         ; LR = return_to_main
; Execution returns here

outer:
SUB SP, SP, #4
STR LR, [SP, #0] ; Save LR (return_to_main)

MOV R1, R0
ADD R0, R0, #10
BL inner         ; LR = return_to_outer (overwrites!)

ADD R0, R0, R1
LDR LR, [SP, #0] ; Restore LR (return_to_main)
ADD SP, SP, #4
MOV PC, LR       ; Returns to main

inner:
MUL R0, R0, R0
MOV PC, LR       ; Returns to outer
</code></pre>


<h2>7.11 Recursion Example: Factorial</h2>

<h3>7.11.1 Factorial Function</h3>

<p><strong>C Code</strong></p>

<pre><code class="language-c">int fact(int n) {
    if (n <= 1)
        return 1;
    else
        return n * fact(n-1);
}
</code></pre>

<p><strong>Key Points</strong></p>

<ul>
<li>Base case: n ≤ 1, return 1</li>
<li>Recursive case: return n × fact(n-1)</li>
<li>Each call creates new stack frame</li>
<li>Stack unwinds as recursion returns</li>
</ul>

<h3>7.11.2 ARM Assembly Implementation</h3>

<pre><code class="language-asm6502">fact:
; Save LR and n
SUB SP, SP, #8
STR LR, [SP, #4]     ; Save return address
STR R0, [SP, #0]     ; Save n

; Base case: if (n <= 1) return 1
CMP R0, #1
BGT recursive
MOV R0, #1           ; Return 1
B fact_end

recursive:
; Recursive case: n * fact(n-1)
SUB R0, R0, #1       ; n-1
BL fact              ; fact(n-1)
LDR R1, [SP, #0]     ; Restore original n
MUL R0, R0, R1       ; n * fact(n-1)

fact_end:
; Restore and return
LDR LR, [SP, #4]
ADD SP, SP, #8
MOV PC, LR
</code></pre>

<h3>7.11.3 Stack Growth During Recursion</h3>

<p><strong>Call: fact(3)</strong></p>

<pre><code>Initial: SP = 0x1000

fact(3) call:
SP = 0x0FF8: [LR_main, 3]

fact(2) call:
SP = 0x0FF0: [LR_fact3, 2]

fact(1) call:
SP = 0x0FE8: [LR_fact2, 1]

Base case returns 1
Unwinds to fact(2): returns 1*2 = 2
Unwinds to fact(3): returns 2*3 = 6
Returns to main with result 6

Final: SP = 0x1000 (restored)
</code></pre>


<p><strong>Stack Space Per Call</strong></p>

<ul>
<li>8 bytes (LR + n)</li>
<li>fact(5) needs 5 × 8 = 40 bytes</li>
<li>fact(10) needs 80 bytes</li>
<li>Deep recursion can overflow stack!</li>
</ul>

<h2>7.12 Memory Layout and Stack vs. Heap</h2>

<h3>7.12.1 Complete Memory Layout</h3>

<pre><code>High Address (0xFFFFFFFF)
┌──────────────┐
│   Reserved   │ OS and system
├──────────────┤
│    Stack     │ ← SP (grows down)
│      ↓       │   Automatic storage
│              │   Function call data
│              │   Local variables
│              │
│   (unused)   │
│              │
│      ↑       │
│    Heap      │   Dynamic allocation
│              │   malloc/free, new/delete
├──────────────┤
│ Static Data  │   Global variables
│              │   String constants
├──────────────┤
│    Text      │   Program instructions
│ (Code)       │   Read-only
└──────────────┘
Low Address (0x00000000)
</code></pre>

<h3>7.12.2 Stack Characteristics</h3>

<p><strong>Automatic Storage</strong></p>

<ul>
<li>Allocated when function called</li>
<li>Released when function returns</li>
<li>Managed automatically by compiler/runtime</li>
</ul>

<p><strong>Fast Access</strong></p>

<ul>
<li>Fixed addressing pattern</li>
<li>SP always points to top</li>
<li>Simple offset calculations</li>
</ul>

<p><strong>Limited Size</strong></p>

<ul>
<li>Typically 1-8 MB</li>
<li>Stack overflow if exceeded</li>
<li>Recursion depth limited</li>
</ul>

<p><strong>Scope</strong></p>

<ul>
<li>Local to function</li>
<li>Not accessible after return</li>
<li>Perfect for temporary data</li>
</ul>

<h3>7.12.3 Heap Characteristics</h3>

<p><strong>Dynamic Allocation</strong></p>

<ul>
<li>malloc/free in C</li>
<li>new/delete in C++</li>
<li>Programmer controls lifetime</li>
</ul>

<p><strong>Flexible Size</strong></p>

<ul>
<li>Can grow large (limited by available memory)</li>
<li>Variable-sized allocations</li>
</ul>

<p><strong>Manual Management</strong></p>

<ul>
<li>Must explicitly free memory</li>
<li>Memory leaks if not freed</li>
<li>Fragmentation possible</li>
</ul>

<p><strong>Global Scope</strong></p>

<ul>
<li>Persists until explicitly freed</li>
<li>Can pass pointers across functions</li>
<li>Suitable for data structures</li>
</ul>

<h2>Key Takeaways</h2>

<ol>
<li><strong>Function calling requires</strong> parameter passing, return value handling, and register preservation.</li>

<li><strong>R0-R3 for arguments and returns</strong> - caller doesn't expect preservation.</li>

<li><strong>R4-R11 must be preserved</strong> by callee if used, protecting caller's data.</li>

<li><strong>BL instruction</strong> saves return address in LR and jumps to function.</li>

<li><strong>Return via MOV PC, LR</strong> copies link register to program counter.</li>

<li><strong>Stack is LIFO structure</strong> growing downward from high addresses, pointed to by SP.</li>

<li><strong>Stack usage</strong> includes saving registers, local variables, return addresses, and extra arguments.</li>

<li><strong>Allocate with SUB SP, release with ADD SP</strong> - must balance allocations and releases.</li>

<li><strong>Non-leaf functions</strong> must save LR to stack before making nested calls.</li>

<li><strong>Recursion</strong> creates multiple stack frames, one per call, unwinding as calls return.</li>

<li><strong>Stack vs. Heap</strong> - stack is automatic/local/fast/limited, heap is manual/global/flexible/larger.</li>

<li><strong>Register conventions</strong> enable modularity and prevent conflicts in shared register file.</li>
</ol>

<h2>Summary</h2>

<p>Function calling mechanisms enable modular programming by providing structured ways to pass control, data, and return values between code sections. ARM's register conventions balance efficiency (passing arguments in registers) with safety (preserving callee-saved registers). The stack provides essential temporary storage for register preservation, local variables, and handling nested calls including recursion. Understanding these mechanisms is crucial for translating high-level function-based code to assembly, optimizing performance, and debugging stack-related issues. The interplay between registers, stack, and calling conventions forms the foundation for understanding how real programs execute, preparing us for more advanced topics like exception handling, operating systems, and compiler optimization.</p>

            
            <div class="lecture-nav">
                <a href="lecture-06.html" class="nav-btn">← Previous Lecture</a>
                <a href="lecture-08.html" class="nav-btn">Next Lecture →</a>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 CO224 Computer Architecture Lecture Series. All rights reserved.</p>
            <p>Department of Computer Engineering, University of Peradeniya</p>
        </div>
    </footer>
</body>
</html>
